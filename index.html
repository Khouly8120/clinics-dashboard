<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Management Dashboard</title>
    
    <!-- PapaParse for CSV Parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/papaparse/5.3.2/papaparse.min.js"></script>
    
    <!-- Google Charts Library -->
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    
    <!-- Date Range Picker Dependencies -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/latest/jquery.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/momentjs/latest/moment.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.css" />

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f5f5f5; color: #333; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; text-align: center; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .last-updated { font-size: 0.9em; opacity: 0.9; }
        .controls { background: white; padding: 20px; margin: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: flex; gap: 20px; flex-wrap: wrap; align-items: center; }
        .filter-group { display: flex; flex-direction: column; gap: 5px; }
        .filter-group label { font-weight: bold; font-size: 0.9em; }
        .filter-group select, .filter-group input { padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 0.9em; }
        .summary-cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin: 20px; }
        .summary-card { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); text-align: center; }
        .summary-card h3 { font-size: 0.9em; color: #666; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
        .summary-card .number { font-size: 2.5em; font-weight: bold; margin-bottom: 5px; }
        .critical { color: #e74c3c; }
        .high { color: #f39c12; }
        .low { color: #f1c40f; }
        .normal { color: #27ae60; }
        .main-table { margin: 20px; background: white; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); overflow: hidden; }
        .table-header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px 20px; font-weight: bold; font-size: 1.1em; display: flex; justify-content: space-between; align-items: center; }
        .view-toggle button { background-color: rgba(255, 255, 255, 0.2); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8em; transition: background-color 0.3s; }
        .view-toggle button.active { background-color: rgba(255, 255, 255, 0.4); font-weight: bold; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #eee; font-size: 0.9em; }
        th { background-color: #f8f9fa; font-weight: bold; position: sticky; top: 0; z-index: 10; }
        th:first-child, td:first-child { position: sticky; left: 0; background: #e9ecef; z-index: 11; }
        thead th:first-child { z-index: 12; background: #dee2e6; }
        tbody tr:hover { background-color: #f8f9fa; }
        .alert-badge { padding: 4px 8px; border-radius: 12px; font-size: 0.8em; font-weight: bold; text-align: center; min-width: 60px; display: inline-block; }
        .alert-critical { background-color: #e74c3c; color: white; }
        .alert-high { background-color: #f39c12; color: white; }
        .alert-low { background-color: #f1c40f; color: #333; }
        .alert-normal { background-color: #27ae60; color: white; }
        .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 2000; color: white; }
        .spinner { border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .tab-container { margin: 20px; }
        .tab-buttons { display: flex; border-bottom: 2px solid #ddd; }
        .tab-button { background: #f1f1f1; border: 1px solid #ccc; padding: 10px 20px; cursor: pointer; font-size: 1em; transition: background-color 0.3s; border-bottom: none; border-radius: 5px 5px 0 0; }
        .tab-button.active { background: white; border-bottom: 2px solid white; position: relative; top: 2px; }
        .tab-content { display: none; padding: 20px; background: white; border: 1px solid #ddd; border-top: none; border-radius: 0 0 10px 10px; }
        .tab-content.active { display: block; }
    </style>
</head>
<body>
    <div id="loadingOverlay" class="loading-overlay">
        <div class="spinner"></div>
        <p id="loadingMessage">Loading...</p>
    </div>

    <div class="header">
        <h1>Management Dashboard</h1>
        <p class="last-updated" id="lastUpdated">Last Updated: N/A</p>
    </div>

    <div class="controls">
        <!-- Filter controls will be populated by JS -->
    </div>

    <div class="summary-cards" id="summaryCards">
        <!-- Summary cards will be populated by JS -->
    </div>

    <div class="tab-container">
        <div class="tab-buttons">
            <button class="tab-button active" onclick="switchTab(event, 'weekly-updates')" disabled>Weekly Updates</button>
            <button class="tab-button" onclick="switchTab(event, 'daily-numbers')" disabled>Daily Numbers</button>
            <button class="tab-button" onclick="switchTab(event, 'meeting-notes')" disabled>Meeting Notes</button>
        </div>

        <div id="weekly-updates" class="tab-content active">
            <div class="main-table">
                <table>
                    <thead>
                        <tr id="mainTableHeader">
                            <!-- Header will be populated by JS -->
                        </tr>
                    </thead>
                    <tbody id="mainTableBody">
                        <!-- Data rows will be populated by JS -->
                    </tbody>
                </table>
            </div>
        </div>

        <div id="daily-numbers" class="tab-content">
            <h2>Daily Numbers</h2>
            <div id="daily-pivot-table-container"></div>
        </div>

        <div id="meeting-notes" class="tab-content">
            <h2>Meeting Notes</h2>
            <div id="meeting-notes-container"></div>
        </div>
    </div>

    <script>
    // ===================================================================================
    // SCRIPT START: MANAGEMENT DASHBOARD (v2 - Clean)
    // ===================================================================================
    
    // --- Email-based Access Control ---
    const allowedEmails = ["operations.bi@ptofthecity.com", "khouly@ptofthecity.com"].map(e => e.toLowerCase());
    const emailInput = prompt("Please enter your email to access the dashboard:");
    const email = emailInput ? emailInput.trim().toLowerCase() : "";
    if (!email || !allowedEmails.includes(email)) {
        alert("Access Denied. You do not have permission to view this dashboard.");
        document.body.innerHTML = '<h1>Access Denied</h1>';
        throw new Error("Access Denied");
    }

    // --- DOMContentLoaded Listener ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM fully loaded. Initializing dashboard...');
        initializeApp();
    });

    // --- Global State & Configuration ---
    let allData = [];
    let dailyData = [];
    let meetingNotesData = [];
    let benchmarks = {};
    let metricsDefinition = [];
    const weeklyDataUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRma8oH8Xa1nBwS_f_3s3s4t5t6u7v8w9x0y1z2a3b4c5d6e7f8g9h0i1j2k3l4m5n6o7p8q9r0s1t2u3v4w5x6y7z8/pub?gid=0&single=true&output=csv';
    const dailyDataUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRma8oH8Xa1nBwS_f_3s3s4t5t6u7v8w9x0y1z2a3b4c5d6e7f8g9h0i1j2k3l4m5n6o7p8q9r0s1t2u3v4w5x6y7z8/pub?gid=123456789&single=true&output=csv'; // TODO: Replace with actual GID
    const meetingNotesUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRma8oH8Xa1nBwS_f_3s3s4t5t6u7v8w9x0y1z2a3b4c5d6e7f8g9h0i1j2k3l4m5n6o7p8q9r0s1t2u3v4w5x6y7z8/pub?gid=987654321&single=true&output=csv'; // TODO: Replace with actual GID

    // --- Main Initialization Function ---
    async function initializeApp() {
        showLoading('Loading all dashboard data...');
        try {
            google.charts.load('current', { packages: ['corechart', 'table'] });
            await new Promise(resolve => google.charts.setOnLoadCallback(resolve));

            const [weekly, daily, notes] = await Promise.all([
                fetchCsv(weeklyDataUrl, 'Weekly Data'),
                fetchCsv(dailyDataUrl, 'Daily Data'),
                fetchCsv(meetingNotesUrl, 'Meeting Notes')
            ]);

            allData = weekly;
            dailyData = daily;
            meetingNotesData = notes;

            console.log('All data fetched:', { weekly: weekly.length, daily: daily.length, notes: notes.length });

            // Process and Render all components
            processWeeklyData();
            renderWeeklyTable();
            renderSummaryCards();
            populateFilters();
            setupDailyNumbersTab();
            setupMeetingNotesTab();

            enableControls();
            hideLoading();
            console.log('Dashboard initialized successfully.');

        } catch (error) {
            console.error('FATAL: Dashboard initialization failed:', error);
            showLoading(`Error: ${error.message}. Please check data sources or network connection.`);
        }
    }

    // --- Data Fetching & Parsing ---
    async function fetchCsv(url, sourceName) {
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status} for ${sourceName}`);
            const text = await response.text();
            if (!text) return []; // Handle empty responses
            const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
            if (parsed.errors.length > 0) {
                console.warn(`Parsing errors in ${sourceName}:`, parsed.errors);
            }
            return parsed.data;
        } catch (error) {
            console.error(`Failed to fetch/parse CSV from ${sourceName} (${url}):`, error);
            throw new Error(`Could not load ${sourceName}`);
        }
    }

    // --- UI Control Functions ---
    const showLoading = (message) => { 
        const overlay = document.getElementById('loadingOverlay');
        const msgElement = document.getElementById('loadingMessage');
        if(overlay) overlay.style.display = 'flex'; 
        if(msgElement) msgElement.textContent = message; 
    };
    const hideLoading = () => { 
        const overlay = document.getElementById('loadingOverlay');
        if(overlay) overlay.style.display = 'none'; 
    };
    const enableControls = () => document.querySelectorAll('.controls select, .controls input, .controls button, .tab-button').forEach(el => el.disabled = false);

    // --- Weekly Updates: Data Processing ---
    function processWeeklyData() {
        if (!allData || allData.length === 0) return;
        const benchmarkRow = allData.find(row => row.Clinic && row.Clinic.toLowerCase() === 'benchmark');
        if (benchmarkRow) {
            benchmarks = benchmarkRow;
            allData = allData.filter(row => row.Clinic && row.Clinic.toLowerCase() !== 'benchmark');
        }
        if (allData.length > 0) {
            metricsDefinition = Object.keys(allData[0]).filter(k => k !== 'Clinic' && k !== 'Time Period');
        }
    }

    // --- Weekly Updates: Rendering ---
    function renderWeeklyTable() {
        const tableHeader = document.getElementById('mainTableHeader');
        const tableBody = document.getElementById('mainTableBody');
        if (!tableHeader || !tableBody) return;

        if (!allData || allData.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="100%">No weekly data available.</td></tr>';
            return;
        }

        // Render Header
        let headerHtml = '<th>Clinic</th>';
        metricsDefinition.forEach(metric => {
            headerHtml += `<th>${metric}</th>`;
        });
        tableHeader.innerHTML = headerHtml;

        // Render Body
        let bodyHtml = '';
        allData.forEach(row => {
            bodyHtml += '<tr>';
            bodyHtml += `<td>${row.Clinic}</td>`;
            metricsDefinition.forEach(metric => {
                bodyHtml += generateMetricCell(row[metric], benchmarks[metric]);
            });
            bodyHtml += '</tr>';
        });
        tableBody.innerHTML = bodyHtml;
    }

    function generateMetricCell(value, target) {
        const val = parseFloat(value);
        const tgt = parseFloat(target);
        let status = 'normal';
        if (!isNaN(val) && !isNaN(tgt)) {
            if (val < tgt * 0.7) status = 'critical';
            else if (val < tgt * 0.9) status = 'high';
            else if (val < tgt * 0.95) status = 'low';
        }
        return `<td><span class="alert-badge alert-${status}">${value || ''}</span></td>`;
    }

    function renderSummaryCards() {
        const container = document.getElementById('summaryCards');
        if(container) container.innerHTML = '<div>Summary Cards Loaded</div>'; // Placeholder
    }

    function populateFilters() {
        const container = document.getElementById('lastUpdated');
        if(container) container.textContent = `Last Updated: ${new Date().toLocaleString()}`;
    }

    // --- Daily Numbers Tab ---
    function setupDailyNumbersTab() {
        const container = document.getElementById('daily-pivot-table-container');
        if(container) container.innerHTML = `<p>Daily numbers data loaded (${dailyData.length} rows).</p>`;
    }

    // --- Meeting Notes Tab ---
    function setupMeetingNotesTab() {
        const container = document.getElementById('meeting-notes-container');
        if (!container) return;
        container.innerHTML = '';
        if (meetingNotesData && meetingNotesData.length > 0) {
            meetingNotesData.forEach(note => {
                const noteEl = document.createElement('div');
                noteEl.innerHTML = `<strong>${note.Clinic || 'N/A'} - ${note.Metric || 'N/A'}:</strong> ${note.Notes || ''}`;
                container.appendChild(noteEl);
            });
        } else {
            container.innerHTML = '<p>No meeting notes found.</p>';
        }
    }

    // --- Event Handlers & Global Functions ---
    function switchTab(event, tabId) {
        document.querySelectorAll('.tab-content').forEach(tab => tab.style.display = 'none');
        document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
        
        const tabToShow = document.getElementById(tabId);
        if (tabToShow) tabToShow.style.display = 'block';
        
        if (event && event.currentTarget) event.currentTarget.classList.add('active');
    }

    // Make functions globally accessible for HTML onclick attributes
    window.switchTab = switchTab;

    </script>
</body>
</html>

        .tab-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: -1px;
        }

        .tab-button {
            padding: 10px 15px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            cursor: pointer;
        }

        .tab-button.active {
            background-color: white;
            border-bottom: 1px solid white;
            font-weight: bold;
        }

        .tab-content {
            display: none;
            background: white;
            border: 1px solid #ddd;
            border-radius: 0 5px 5px 5px;
            padding: 20px;
        }

        .tab-content.active {
            display: block;
        }

        .meeting-notes-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            padding: 20px;
        }

        .meeting-box {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 15px;
            width: 300px;
            min-height: 200px;
        }

        .meeting-box h3 {
            margin-top: 0;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
            font-size: 1.1em;
        }

        .meeting-checklist {
            list-style-type: none;
            padding: 0;
        }

        .meeting-checklist li {
            margin-bottom: 10px;
            padding: 8px;
            background-color: #f9f9f9;
            border-radius: 4px;
        }

        .meeting-clinic { font-weight: bold; color: #2c3e50; }
        .meeting-metric { color: #3498db; }
        .meeting-notes { margin-top: 5px; color: #666; font-size: 0.9em; }

    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div>
            <div class="spinner"></div>
            <p id="loadingMessage">Loading Dashboard Data...</p>
        </div>
    </div>

    <div class="header">
        <h1>Management Clinic Dashboard</h1>
        <div class="last-updated" id="lastUpdated">Loading...</div>
    </div>

    <div class="controls">
        <div class="filter-group">
            <label>Filter by Alert Level:</label>
            <select id="alertFilter" onchange="filterTable()" disabled>
                <option value="all">All Alerts</option>
                <option value="critical">Critical Only</option>
                <option value="high">High Only</option>
                <option value="low">Low Only</option>
                <option value="slight">Slight Only</option>
                <option value="normal">Normal Only</option>
            </select>
        </div>
        <div class="filter-group">
            <label>Filter by Clinic:</label>
            <select id="clinicFilter" onchange="filterTable()" disabled>
                <option value="all">All Clinics</option>
            </select>
        </div>
        <div class="filter-group">
            <label>Search Clinic:</label>
            <input type="text" id="searchInput" placeholder="Type clinic name..." onkeyup="filterTable()" disabled>
        </div>
        <div class="filter-group">
            <label>Time Period:</label>
            <select id="timePeriodFilter" onchange="changeTimePeriod()" disabled></select>
        </div>
    </div>

    <div class="summary-cards" id="summaryCards">
         <div class="summary-card"><p>Loading data...</p></div>
    </div>

    <div class="tab-container">
        <div class="tab-buttons">
            <button class="tab-button active" onclick="switchTab(event, 'currentData')">Weekly Updates</button>
            <button class="tab-button" onclick="switchTab(event, 'dailyTab')">Daily Numbers</button>
            <button class="tab-button" onclick="switchTab(event, 'meetingNotesTab')">Meeting Notes</button>
        </div>
        
        <div class="tab-content active" id="currentData">
            <div class="responsive-table" id="tableView" style="overflow: auto; max-height: 600px;">
                <table id="metricsTable">
                    <thead></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div class="tab-content" id="dailyTab">
            <div class="controls">
                 <div class="filter-group">
                    <label for="dailyMetricSelector">Select Metric:</label>
                    <select id="dailyMetricSelector"></select>
                </div>
                <div class="filter-group">
                    <label for="dailyDateRange">Select Date Range:</label>
                    <input type="text" id="dailyDateRange" class="date-range-picker" />
                </div>
            </div>
            <div id="daily-pivot-table-container" class="responsive-table" style="overflow: auto; max-height: 600px;"></div>
        </div>

        <div class="tab-content" id="meetingNotesTab">
            <div id="meeting-notes-container" class="meeting-notes-container"></div>
        </div>
    </div>

<script>
    google.charts.load('current', {'packages':['corechart', 'table']});
    google.charts.setOnLoadCallback(init);

    let allData = [];
    let dailyData = [];
    let filteredData = [];
    const weeklySheetUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQ2p_Vp-q7tG3V6V_h_p_s-sI0kz1c_0J6aT_lGg-2-gXJ-pE-0aJ8aY_A8e-f_b_cE-0/pub?gid=1927988355&single=true&output=csv';
    const dailySheetUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQ2p_Vp-q7tG3V6V_h_p_s-sI0kz1c_0J6aT_lGg-2-gXJ-pE-0aJ8aY_A8e-f_b_cE-0/pub?gid=82527434&single=true&output=csv';
    const meetingNotesUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQ2p_Vp-q7tG3V6V_h_p_s-sI0kz1c_0J6aT_lGg-2-gXJ-pE-0aJ8aY_A8e-f_b_cE-0/pub?gid=1242302533&single=true&output=csv';

    const metricsDefinition = [
        { id: 'New Patients', name: 'New Patients', type: 'number', higherIsBetter: true, benchmark: 10 },
        { id: 'Visits Target', name: 'Visits Target', type: 'percentage', higherIsBetter: true, benchmark: 0.95 },
        { id: 'Daily Dist', name: 'Daily Dist', type: 'percentage', higherIsBetter: true, benchmark: 0.9 },
        { id: 'Cancellations', name: 'Cancellations', type: 'percentage', higherIsBetter: false, benchmark: 0.1 },
        { id: 'Evols', name: 'Evols', type: 'number', higherIsBetter: true, benchmark: 15 },
        { id: 'Self Discharge', name: 'Self Discharge', type: 'percentage', higherIsBetter: false, benchmark: 0.05 }
    ];

    function showLoading(message = 'Loading...') {
        document.getElementById('loadingMessage').textContent = message;
        document.getElementById('loadingOverlay').style.display = 'flex';
    }

    function hideLoading() {
        document.getElementById('loadingOverlay').style.display = 'none';
    }

    async function fetchData(url) {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Failed to fetch data from ${url}`);
        return await response.text();
    }

    function parseCSV(csv) {
        const lines = csv.split(/\r\n|\n/);
        const headers = lines[0].split(',').map(h => h.trim());
        return lines.slice(1).map(line => {
            const values = line.split(',');
            return headers.reduce((obj, header, index) => {
                obj[header] = values[index] ? values[index].trim() : '';
                return obj;
            }, {});
        });
    }

    function getAlertLevel(metric, value) {
        if (metric.type === 'percentage') value = parseFloat(value) / 100;
        else value = parseFloat(value);

        if (isNaN(value)) return 'normal'; // Default for non-numeric data

        const deviation = (value - metric.benchmark) / metric.benchmark;
        const effectiveDeviation = metric.higherIsBetter ? deviation : -deviation;

        if (effectiveDeviation < -0.25) return 'critical';
        if (effectiveDeviation < -0.10) return 'high';
        if (effectiveDeviation < 0) return 'low';
        return 'normal';
    }

    function populateClinicFilter(data) {
        const clinics = [...new Set(data.map(item => item.Clinic))].sort();
        const selector = document.getElementById('clinicFilter');
        clinics.forEach(clinic => {
            const option = document.createElement('option');
            option.value = clinic;
            option.textContent = clinic;
            selector.appendChild(option);
        });
    }

    function populateTimePeriodFilter(data) {
        const dates = [...new Set(data.map(item => item.Date))].sort((a, b) => new Date(b) - new Date(a));
        const selector = document.getElementById('timePeriodFilter');
        dates.forEach(date => {
            const option = document.createElement('option');
            option.value = date;
            option.textContent = new Date(date).toLocaleDateString();
            selector.appendChild(option);
        });
    }

    function renderTable(data) {
        const tableBody = document.querySelector('#metricsTable tbody');
        const tableHead = document.querySelector('#metricsTable thead');
        tableBody.innerHTML = '';
        tableHead.innerHTML = '';

        if (data.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="100%">No data available for the selected filters.</td></tr>';
            return;
        }

        const headers = ['Clinic', 'Date', ...metricsDefinition.map(m => m.name)];
        const headerRow = document.createElement('tr');
        headers.forEach(h => {
            const th = document.createElement('th');
            th.textContent = h;
            headerRow.appendChild(th);
        });
        tableHead.appendChild(headerRow);

        data.forEach(row => {
            const tr = document.createElement('tr');
            const cells = [row.Clinic, new Date(row.Date).toLocaleDateString(), ...metricsDefinition.map(metric => {
                const value = row[metric.id];
                const alertLevel = getAlertLevel(metric, value);
                return `<td class="metric-value"><span class="alert-badge alert-${alertLevel}">${value}</span></td>`;
            })];
            tr.innerHTML = cells.join('');
            tableBody.appendChild(tr);
        });
    }

    function updateSummaryCards(data) {
        const container = document.getElementById('summaryCards');
        container.innerHTML = '';
        metricsDefinition.forEach(metric => {
            const card = document.createElement('div');
            card.className = 'summary-card';
            const values = data.map(row => parseFloat(row[metric.id])).filter(v => !isNaN(v));
            const average = values.length ? (values.reduce((a, b) => a + b, 0) / values.length) : 0;
            const displayValue = metric.type === 'percentage' ? `${average.toFixed(1)}%` : average.toFixed(1);
            const alertLevel = getAlertLevel(metric, average);
            card.innerHTML = `<h3>${metric.name}</h3><div class="number ${alertLevel}">${displayValue}</div>`;
            container.appendChild(card);
        });
    }

    function filterTable() {
        const alertFilter = document.getElementById('alertFilter').value;
        const clinicFilter = document.getElementById('clinicFilter').value;
        const searchInput = document.getElementById('searchInput').value.toLowerCase();
        const timePeriod = document.getElementById('timePeriodFilter').value;

        filteredData = allData.filter(row => {
            const matchesTime = row.Date === timePeriod;
            const matchesClinic = clinicFilter === 'all' || row.Clinic === clinicFilter;
            const matchesSearch = !searchInput || row.Clinic.toLowerCase().includes(searchInput);
            if (!matchesTime || !matchesClinic || !matchesSearch) return false;

            if (alertFilter !== 'all') {
                return metricsDefinition.some(metric => {
                    return getAlertLevel(metric, row[metric.id]) === alertFilter;
                });
            }
            return true;
        });
        renderTable(filteredData);
    }

    function changeTimePeriod() {
        filterTable();
        const timePeriod = document.getElementById('timePeriodFilter').value;
        const periodData = allData.filter(row => row.Date === timePeriod);
        updateSummaryCards(periodData);
    }

    function switchTab(event, tabName) {
        document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
        document.querySelectorAll('.tab-button').forEach(tb => tb.classList.remove('active'));
        document.getElementById(tabName).classList.add('active');
        event.currentTarget.classList.add('active');

        if (tabName === 'dailyTab' && !document.getElementById('dailyMetricSelector').hasChildNodes()) {
            populateMetricSelector();
            initializeDateRangePicker();
            renderDailyPivot();
        } else if (tabName === 'meetingNotesTab' && !document.getElementById('meeting-notes-container').hasChildNodes()) {
            fetchMeetingNotes();
        }
    }

    function populateMetricSelector() {
        const selector = document.getElementById('dailyMetricSelector');
        selector.innerHTML = '';
        metricsDefinition.forEach(metric => {
            const option = document.createElement('option');
            option.value = metric.id;
            option.textContent = metric.name;
            selector.appendChild(option);
        });
        selector.onchange = renderDailyPivot;
    }

    function initializeDateRangePicker() {
        $('#dailyDateRange').daterangepicker({
            opens: 'left',
            startDate: moment().subtract(7, 'days'),
            endDate: moment()
        }, function(start, end, label) {
            renderDailyPivot();
        });
    }

    function renderDailyPivot() {
        const container = document.getElementById('daily-pivot-table-container');
        const selectedMetricId = document.getElementById('dailyMetricSelector').value;
        const metric = metricsDefinition.find(m => m.id === selectedMetricId);
        if (!metric) {
            container.innerHTML = '<p>Please select a metric.</p>';
            return;
        }

        const dateRange = $('#dailyDateRange').data('daterangepicker');
        const startDate = dateRange.startDate;
        const endDate = dateRange.endDate;

        const filtered = dailyData.filter(row => {
            const rowDate = moment(row.Date, ['M/D/YYYY', 'YYYY-MM-DD', 'MM/DD/YYYY'], true);
            return rowDate.isValid() && rowDate.isBetween(startDate, endDate, 'day', '[]');
        });

        const pivotData = {};
        filtered.forEach(row => {
            if (!pivotData[row.Clinic]) {
                pivotData[row.Clinic] = {};
            }
            const formattedDate = moment(row.Date, ['M/D/YYYY', 'YYYY-MM-DD', 'MM/DD/YYYY'], true).format('YYYY-MM-DD');
            pivotData[row.Clinic][formattedDate] = row[selectedMetricId];
        });

        const allDates = [...new Set(filtered.map(row => moment(row.Date, ['M/D/YYYY', 'YYYY-MM-DD', 'MM/DD/YYYY'], true).format('YYYY-MM-DD')))].sort();
        const clinics = Object.keys(pivotData).sort();

        let table = '<table class="comparison-table"><thead><tr><th>Clinic</th>';
        allDates.forEach(date => table += `<th>${moment(date).format('ddd, MMM D')}</th>`);
        table += '</tr></thead><tbody>';

        clinics.forEach(clinic => {
            table += `<tr><td class="metric-name">${clinic}</td>`;
            allDates.forEach(date => {
                const value = pivotData[clinic][date] || 'N/A';
                const alertLevel = value !== 'N/A' ? getAlertLevel(metric, value) : 'normal';
                table += `<td class="metric-value"><span class="alert-badge alert-${alertLevel}">${value}</span></td>`;
            });
            table += '</tr>';
        });

        table += '</tbody></table>';
        container.innerHTML = table;
    }

    async function fetchMeetingNotes() {
        const container = document.getElementById('meeting-notes-container');
        try {
            showLoading('Loading Meeting Notes...');
            const csv = await fetchData(meetingNotesUrl);
            const notes = parseCSV(csv);
            const notesByClinic = {};
            notes.forEach(note => {
                if (!notesByClinic[note.Clinic]) {
                    notesByClinic[note.Clinic] = [];
                }
                notesByClinic[note.Clinic].push(note);
            });

            container.innerHTML = '';
            Object.keys(notesByClinic).sort().forEach(clinic => {
                const box = document.createElement('div');
                box.className = 'meeting-box';
                let listItems = '';
                notesByClinic[clinic].forEach(note => {
                    listItems += `<li>
                        <div class="meeting-metric">${note.Metric}</div>
                        <div class="meeting-notes">${note.Notes}</div>
                    </li>`;
                });
                box.innerHTML = `<h3>${clinic}</h3><ul class="meeting-checklist">${listItems}</ul>`;
                container.appendChild(box);
            });
        } catch (error) {
            console.error('Error fetching meeting notes:', error);
            container.innerHTML = '<p>Could not load meeting notes. The data source may be unavailable. Please try again later.</p>';
        } finally {
            hideLoading();
        }
    }

    async function init() {
        try {
            showLoading('Loading weekly data...');
            const [weeklyCsv, dailyCsv] = await Promise.all([
                fetchData(weeklySheetUrl),
                fetchData(dailySheetUrl)
            ]);

            allData = parseCSV(weeklyCsv);
            dailyData = parseCSV(dailyCsv);

            document.getElementById('lastUpdated').textContent = `Last Updated: ${new Date().toLocaleString()}`;
            
            populateClinicFilter(allData);
            populateTimePeriodFilter(allData);
            
            const controls = document.querySelectorAll('.controls select, .controls input, .controls button');
            controls.forEach(c => c.disabled = false);

            changeTimePeriod(); // Initial render

        } catch (error) {
            console.error('Initialization failed:', error);
            document.getElementById('loadingMessage').textContent = `Error: ${error.message}. Please check the console and refresh.`;
        } finally {
            hideLoading();
        }
    }

</script>
</body>
</html>
                                    <th>Utilization</th>
                                    <th>Retention (2nd)</th>
                                    <th>Retention (5th)</th>
                                    <th>Retention (10th)</th>
                                    <th>Retention (15th)</th>
                                    <th>Cancel</th>
                                    <th>No Show</th>
                                    <th>No Upcoming</th>
                                    <th>Units</th>
                                    <th>Insurance Coding</th>
                                    <th>Support Coding</th>
                                    <th>Average Visits</th>
                                    <th>Confirmation</th>
                                    <th>Direct Access</th>
                                    <th>Survey</th>
                                    <th>Satisfaction</th>
                                    <th>Overall</th>
                                    <th>Trend</th>
                                    <th>Action</th>
                                </tr>
                            </thead>
                            <tbody id="tableBody">
                                <tr><td colspan="23" style="text-align: center;">Loading data...</td></tr> <!-- Updated colspan -->
                            </tbody>
                        </table>
                    </div>
                    <div id="cardView" style="display: none; padding: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                        <!-- Card view content will be populated dynamically -->
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="historicalTrends">
                <div class="historical-data-section">
                    <div class="table-header">
                        Historical Data Analysis
                    </div>
                    <div class="chart-controls">
                        <div class="filter-group">
                            <label>Date Range:</label>
                            <input type="text" id="dateRangePicker" class="date-range-picker" disabled/>
                        </div>
                        <div class="filter-group">
                            <label>Select Clinic:</label>
                            <select id="clinicSelector" onchange="updateHistoricalCharts()" disabled>
                                <option value="all">All Clinics</option>
                                <!-- Clinic options will be populated dynamically -->
                            </select>
                        </div>
                        <div class="filter-group">
                            <label>Select Metric:</label>
                            <div class="metric-selector" id="metricSelector">
                                <!-- Buttons populated dynamically -->
                            </div>
                        </div>
                    </div>
                    <div class="chart-container" id="trendChart"><p>Loading data...</p></div>
                    <div class="chart-container" id="comparisonChart"></div>
                </div>
            </div>
    
            <div class="tab-content" id="comparisonTab">
                <div class="comparison-controls">
                    <div class="filter-group">
                        <label>Comparison Type:</label>
                        <div class="comparison-type-selector">
                            <button class="active" onclick="switchComparisonType(event, 'week-to-week')" disabled>Week-to-Week</button>
                            <button onclick="switchComparisonType(event, '4-weeks')" disabled>Compare 4 Weeks</button>
                            <button onclick="switchComparisonType(event, 'custom-ranges')" disabled>Compare Custom Ranges</button>
                        </div>
                    </div>
    
                    <div id="comparisonOptionsWeekToWeek" class="comparison-options active">
                        <div class="filter-group">
                            <label>Select Clinic:</label>
                            <select id="compareClinicSelectorW2W" disabled>
                                <option value="all">All Clinics</option>
                                <!-- Clinic options will be populated dynamically -->
                            </select>
                        </div>
                        <button class="action-button" onclick="runComparison('week-to-week')" disabled>Run Comparison</button>
                    </div>
    
                    <div id="comparisonOptions4Weeks" class="comparison-options">
                        <div class="filter-group">
                            <label>Select Clinic:</label>
                            <select id="compareClinicSelector4W" disabled>
                                <option value="all">All Clinics</option>
                                <!-- Clinic options will be populated dynamically -->
                            </select>
                        </div>
                        <div class="filter-group">
                            <label>Select Weeks:</label>
                            <div class="week-selectors">
                                <select id="compareWeek1" disabled></select>
                                <select id="compareWeek2" disabled></select>
                                <select id="compareWeek3" disabled></select>
                                <select id="compareWeek4" disabled></select>
                            </div>
                        </div>
                        <button class="action-button" onclick="runComparison('4-weeks')" disabled>Run Comparison</button>
                    </div>
    
                    <div id="comparisonOptionsCustomRanges" class="comparison-options">
                        <div class="filter-group">
                            <label>Select Clinic:</label>
                            <select id="compareClinicSelectorCR" disabled>
                                <option value="all">All Clinics</option>
                                <!-- Clinic options will be populated dynamically -->
                            </select>
                        </div>
                        <div class="filter-group">
                            <label>Select Ranges:</label>
                            <div class="range-pickers">
                                <input type="text" id="compareRangePicker1" class="date-range-picker" disabled/>
                                <input type="text" id="compareRangePicker2" class="date-range-picker" disabled/>
                            </div>
                        </div>
                        <button class="action-button" onclick="runComparison('custom-ranges')" disabled>Run Comparison</button>
                    </div>
                </div>
    
                <div class="comparison-results" id="comparisonResults">
                     <p>Loading data...</p>
                </div>
            </div>
    
            <div class="tab-content" id="dailyTab">
                <div class="table-header">Daily Numbers 
                    <label for="dateRangePickerDaily" style="margin-left:15px;font-weight:bold;">Filter by Date:</label>
                    <input type="text" id="dateRangePickerDaily" class="date-range-picker" placeholder="mm/dd/yyyy - mm/dd/yyyy" style="margin-left:8px;" onchange="renderDailyPivot()">
                    <select id="dailyMetricSelector" style="margin-left:15px;" onchange="renderDailyPivot()">
                        <option value="targetVisits">Target Visits</option>
                        <option value="googleReviews">Google Reviews</option>
                        <option value="newPatients">New Patients Target</option>
                        <option value="noUpcoming">No Upcoming %</option>
                        <option value="cancellation">Cancellation %</option>
                        <option value="noShow">No Show %</option>
                        <option value="utilization">Utilization %</option>
                        <option value="satisfactionCollect">Satisfaction Collection %</option>
                    </select>
                </div>
                <div class="responsive-table" style="overflow:auto;max-height:500px;">
                    <table id="dailyTable"><thead id="dailyTableHead"></thead>
                        <tbody id="dailyTableBody"><tr><td style="text-align:center;">Loading...</td></tr></tbody></table>
                </div>
            </div>
        </div>
    
        <div class="details-panel" id="detailsPanel">
            <div class="details-header">
                <h2 id="detailsTitle">Clinic Details</h2>
                <button class="close-btn" onclick="closeDetails()">&times;</button>
            </div>
            <div class="details-content" id="detailsContent">
                <!-- Details will be populated dynamically -->
            </div>
        </div>
    
        <script>
            // Load Google Charts
            google.charts.load('current', {'packages':['corechart', 'line', 'table']});
            google.charts.setOnLoadCallback(setupDashboard);
            
            async function setupDashboardAsync(){
                await Promise.all([loadDataAndBenchmarks(), loadDailyData()]);
                initializeTabs();
                renderCurrentWeek();
                renderDailyCurrent();
            }
    
            // --- Configuration ---
            // HARDCODED Google Sheet URLs - Replace these if your published sheet URLs change
            const googleSheetDataUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQeN0UumxiDN3Qp5H8J0bKZOvkMgRBvNe-G8KYja32gNGE_Rws90BGR4EShDrpXoqWiuZpnfaKmrAzN/pub?gid=0&single=true&output=csv'; 
            const googleSheetBenchmarkUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQeN0UumxiDN3Qp5H8J0bKZOvkMgRBvNe-G8KYja32gNGE_Rws90BGR4EShDrpXoqWiuZpnfaKmrAzN/pub?gid=1294580086&single=true&output=csv'; 
            // DAILY metrics (Target Visits & Google Reviews)
            const googleSheetDailyDataUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQeN0UumxiDN3Qp5H8J0bKZOvkMgRBvNe-G8KYja32gNGE_Rws90BGR4EShDrpXoqWiuZpnfaKmrAzN/pub?gid=1535490642&single=true&output=csv';
            const googleSheetDailyBenchmarkUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQeN0UumxiDN3Qp5H8J0bKZOvkMgRBvNe-G8KYja32gNGE_Rws90BGR4EShDrpXoqWiuZpnfaKmrAzN/pub?gid=1352823327&single=true&output=csv';
    
            // --- Global variables for Daily Metrics ---
            let allClinicsDailyData = {};
            let dailyBenchmarkData = {};
    let latestDailyBenchmarkByClinic = {}; // fallback map
            let latestDailyDate = ''; 
    
            // --- Data Definitions ---
            // Note: AreaManagerNotes removed, AreaManagerNotesAlert kept (no benchmark)
            const metricsDefinition = [
                // { id: 'areaManagerNotes', name: 'Area Manager Notes', target: null, higherIsBetter: null, type: 'text' }, // Removed
                { id: 'newPatients', name: 'New Patients %', type: 'percentage' },
                { id: 'visitsTarget', name: 'Visits Target %', type: 'percentage' },
                { id: 'dailyDistribution', name: 'Daily Distribution', type: 'number' }, 
                { id: 'utilization', name: 'Utilization Rate %', type: 'percentage' },
                { id: 'retention2nd', name: 'Retention 2nd %', type: 'percentage' },
                { id: 'retention5th', name: 'Retention 5th %', type: 'percentage' },
                { id: 'retention10th', name: 'Retention 10th %', type: 'percentage' },
                { id: 'retention15th', name: 'Retention 15th %', type: 'percentage' },
                { id: 'cancel', name: 'Cancel %', type: 'percentage', higherIsBetter: false },
                { id: 'noShow', name: 'No Show %', type: 'percentage', higherIsBetter: false },
                { id: 'noUpcoming', name: 'No Upcoming %', type: 'percentage', higherIsBetter: false },
                { id: 'units', name: 'Units %', type: 'percentage' },
                { id: 'insuranceCoding', name: 'Insurance Utilization Coding %', type: 'percentage' },
                { id: 'supportiveCoding', name: 'Supportive Coding %', type: 'percentage' },
                { id: 'averageVisits', name: 'Average Number of Visits', type: 'number' },
                { id: 'confirmation', name: 'Confirmation %', type: 'percentage' },
                { id: 'directAccess', name: 'Direct Access %', type: 'percentage', higherIsBetter: false },
                { id: 'surveyCollection', name: 'Survey Collection %', type: 'percentage' },
                { id: 'satisfaction', name: 'Hospitality/Clinical Satisfaction %', type: 'percentage' },
                // --- Daily metrics ---
                { id: 'targetVisits', name: 'Target of Visits', type: 'number' },
                { id: 'googleReviews', name: 'Google Reviews', type: 'number' }
             ];
            // Expected headers for the DATA sheet
            const expectedDataCsvHeaders = [
                'Clinic', 'Week', 'Year', 'Date', 'AreaManagerNotesAlert',
                'NewPatients', 'VisitsTarget', 'DailyDistribution', 'Utilization', 
                'Retention2nd', 'Retention5th', 'Retention10th', 'Retention15th', 
                'Cancel', 'NoShow', 'NoUpcoming', 'Units', 'InsuranceCoding', 
                'SupportiveCoding', 'AverageVisits', 'Confirmation', 'DirectAccess', 'SurveyCollection', 'Satisfaction', 'TargetVisits', 'GoogleReviews'
            ];
            // Expected headers for the BENCHMARK sheet (Metric names + _HigherIsBetter)
            const expectedBenchmarkCsvHeaders = [
                'Year', 'Week',
                ...metricsDefinition.map(m => m.id.charAt(0).toUpperCase() + m.id.slice(1)), // Metric names (e.g., NewPatients)
                ...metricsDefinition.map(m => m.id.charAt(0).toUpperCase() + m.id.slice(1) + '_HigherIsBetter') // HigherIsBetter flags
            ];
    
            // --- Global Variables ---
            let allClinicsData = {}; // Stores processed data keyed by clinic name { clinicName: [weekData1, weekData2,...] }
            let benchmarkData = {}; // Stores benchmark data keyed by 'Year-Week' { '2024-23': { NewPatients: 90, NewPatients_HigherIsBetter: true, ... } }
            let currentWeekData = []; // Data for the currently selected week/period
            let displayedData = []; // Data currently shown in the table/cards after filtering
            let availableWeeks = []; // Array of {year, week} objects found in data
            // Daily globals
            allClinicsDailyData = {}; // reset daily data
            dailyBenchmarkData = {};  // reset daily benchmarks
            latestDailyDate = '';
            let latestWeek = { year: 0, week: 0 };
            let previousWeek = { year: 0, week: 0 };
            let currentView = 'table';
            let selectedMetric = 'newPatients'; // Default metric for historical charts
            let selectedClinic = 'all'; // Default clinic for historical charts
            let trendChart;
            let comparisonChart;
            let dateRange = {
                start: moment().subtract(8, 'weeks'),
                end: moment()
            };
            let validationMessages = []; // Store validation messages
    
            // --- Core Functions ---
    
            // Initial setup function called after Google Charts loads
            async function setupDashboard() {
                console.log("Dashboard setup initiated.");
                initializeDatePickers();
                initializeDailyRangePicker();
                populateMetricSelector();
                
                if (googleSheetDataUrl && googleSheetBenchmarkUrl) {
                     console.log(`Attempting to autoload data from: ${googleSheetDataUrl}`);
                     console.log(`Attempting to autoload benchmarks from: ${googleSheetBenchmarkUrl}`);
                     await Promise.all([initializeDashboard(), loadDailyData()]); // load weekly and daily data in parallel
                } else {
                     addValidationMessage('error', "Configuration Error: Data or Benchmark Google Sheet URL is not configured in the script.");
                     displayValidationMessages();
                     hideLoading("Configuration Error");
                     disableControls();
                }
            }
            
            // Main function to fetch, process, and display data
            async function initializeDashboard() {
                console.log("Initializing dashboard with data fetch...");
                showLoading("Fetching data and benchmarks...");
                validationMessages = []; // Clear previous validation messages
                allClinicsData = {}; // Reset data
                benchmarkData = {};
                availableWeeks = [];
                latestWeek = { year: 0, week: 0 };
                previousWeek = { year: 0, week: 0 };
                
                try {
                    // Fetch both sheets concurrently
                    const [csvDataText, csvBenchmarkText] = await Promise.all([
                        fetchDataFromSheet(googleSheetDataUrl, 'Data'),
                        fetchDataFromSheet(googleSheetBenchmarkUrl, 'Benchmark')
                    ]);
                    
                    showLoading("Processing benchmarks...");
                    const parsedBenchmarks = parseBenchmarkCSVData(csvBenchmarkText);
                    if (!parsedBenchmarks || Object.keys(parsedBenchmarks).length === 0) {
                        addValidationMessage('warning', "No valid benchmark data found or processed. Using default fallback benchmarks.");
                        // Proceed without benchmarks or use defaults? For now, proceed and handle missing benchmarks later.
                    } else {
                         benchmarkData = parsedBenchmarks;
                         addValidationMessage('success', `Successfully processed ${Object.keys(benchmarkData).length} weeks of benchmark data.`);
                    }
                    
                    showLoading("Processing clinic data...");
                    const parsedData = parseCSVData(csvDataText);
                    if (!parsedData || parsedData.length === 0) {
                        throw new Error("No valid clinic data found or processed from the Data sheet.");
                    }
                    addValidationMessage('success', `Successfully processed ${parsedData.length} clinic data entries.`);
                    
                    showLoading("Calculating alerts and trends...");
                    processAndStoreData(parsedData); // Pass benchmarkData implicitly (it's global)
                    
                    if (availableWeeks.length === 0) {
                         throw new Error("No valid weekly data could be processed after applying benchmarks and validation.");
                    }
    
                    // Set initial time period to the latest week
                    currentWeekData = getDataForWeek(latestWeek.year, latestWeek.week);
                    displayedData = currentWeekData;
    
                    // Update UI elements
                    populateTimePeriodFilter();
                    populateClinicOptions();
                    populateWeekSelectors(); // For comparison tab
                    updateSummaryCards(displayedData);
                    populateTable(displayedData);
                    populateCardView(displayedData);
                    updateLastUpdated();
                    updateHistoricalCharts(); // Initial chart draw
                    enableControls(); // Enable UI controls now that data is loaded
                    document.getElementById('dateFilter').disabled = false;
    
    
                    
                    console.log("Dashboard Initialized Successfully.");
        // Enable view toggle buttons & comparison controls now that data loaded
        document.querySelectorAll('.view-toggle button').forEach(b=>b.disabled=false);
        document.querySelectorAll('#comparisonTab button, #comparisonTab select').forEach(el=>el.disabled=false);
                    // displayValidationMessages(); // Validation messages hidden on success
                    initializeMeetingNotesTab();
                    hideLoading();
    
                } catch (error) {
                    console.error("Dashboard Initialization Failed:", error);
                    addValidationMessage('error', `Initialization Failed: ${error.message}`);
                    displayValidationMessages();
                    hideLoading(`Error: ${error.message}`);
                    disableControls(); // Keep controls disabled on error
                }
            }
    
            // Fetch data from a Google Sheet URL
            async function fetchDataFromSheet(url, sheetName) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        // Provide more specific error based on status code
                        let errorMsg = `Failed to fetch ${sheetName} sheet. Status: ${response.status} ${response.statusText}.`;
                        if (response.status === 404) {
                            errorMsg += " Please ensure the URL is correct and the sheet is published as CSV.";
                        } else if (response.status === 403) {
                             errorMsg += " Access denied. Ensure the sheet is published correctly ('Anyone with the link').";
                        } else {
                             errorMsg += " Check network connection and URL.";
                        }
                        throw new Error(errorMsg);
                    }
                    const csvText = await response.text();
                    if (!csvText || csvText.trim().length === 0) {
                         throw new Error(`Fetched CSV data for ${sheetName} sheet is empty.`);
                    }
                    console.log(`${sheetName} CSV Data fetched successfully.`);
                    return csvText;
                } catch (error) {
                    console.error(`Fetch Error (${sheetName}):`, error);
                    // Distinguish network errors from fetch failures
                    if (error instanceof TypeError) { // Likely a network error (e.g., CORS if run locally)
                         throw new Error(`Network error fetching ${sheetName} sheet: ${error.message}. If running locally, try using a local server (e.g., 'python -m http.server').`);
                    } else {
                         throw new Error(`Error fetching ${sheetName} sheet: ${error.message}`);
                    }
                }
            }
            
            // Robust CSV row parser (handles quoted commas)
            function parseCsvRow(rowString) {
                const values = [];
                let currentVal = '';
                let inQuotes = false;
                for (let i = 0; i < rowString.length; i++) {
                    const char = rowString[i];
                    if (char === '"') {
                        if (inQuotes && rowString[i+1] === '"') {
                            // Escaped quote
                            currentVal += '"';
                            i++; // Skip next quote
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        values.push(currentVal.trim());
                        currentVal = '';
                    } else {
                        currentVal += char;
                    }
                }
                values.push(currentVal.trim()); // Add the last value
                return values;
            }
    
            // Parse Clinic Data CSV text into an array of objects
            function parseCSVData(csvText) {
                console.log("Parsing Clinic Data CSV...");
                const lines = csvText.trim().split(/\r?\n/);
                if (lines.length < 2) {
                    addValidationMessage('error', "Clinic Data CSV Error: Must have at least a header row and one data row.");
                    return [];
                }
                
                const headers = lines[0].split(',').map(h => h.trim());
                console.log("Data CSV Headers:", headers);
    
                // Validate headers
                const missingHeaders = expectedDataCsvHeaders.filter(h => !headers.includes(h));
                if (missingHeaders.length > 0) {
                    addValidationMessage('error', `Clinic Data CSV Error: Missing required columns: ${missingHeaders.join(', ')}.`);
                    // Continue parsing with available columns, but warn user
                }
                const extraHeaders = headers.filter(h => !expectedDataCsvHeaders.includes(h));
                 if (extraHeaders.length > 0) {
                     addValidationMessage('warning', `Clinic Data CSV Warning: Found unexpected columns: ${extraHeaders.join(', ')}. These will be ignored.`);
                 }
                
                const data = [];
                let skippedRowCount = 0;
                for (let i = 1; i < lines.length; i++) {
                    const rowNum = i + 1;
                    if (!lines[i].trim()) continue; // Skip empty lines
                    
                    const values = parseCsvRow(lines[i]); 
                    if (values.length !== headers.length) {
                         addValidationMessage('warning', `Clinic Data CSV Warning (Row ${rowNum}): Skipped row due to incorrect number of columns (${values.length} found, ${headers.length} expected). Line: '${lines[i]}'`);
                         skippedRowCount++;
                         continue;
                    }
                    
                    const entry = {};
                    let validEntry = true;
                    let rowErrors = [];
                    for (let j = 0; j < headers.length; j++) {
                        const header = headers[j];
                        // Only process expected headers
                        if (!expectedDataCsvHeaders.includes(header)) continue;
                        
                        let value = values[j];
                        
                        // Basic type conversion and validation
                        if (header === 'Week' || header === 'Year') {
                            const num = parseInt(value);
                            if (isNaN(num) || value.trim() === '') {
                                rowErrors.push(`Invalid/missing value for ${header}: '${value}'`);
                                validEntry = false;
                                entry[header] = null; // Store as null
                            } else {
                                entry[header] = num;
                            }
                        } else if (header === 'Clinic' || header === 'AreaManagerNotesAlert') {
                            if (!value || value.trim() === '') {
                                 if (header === 'Clinic') { // Clinic is essential
                                     rowErrors.push(`Missing essential value for ${header}`);
                                     validEntry = false;
                                 }
                                 entry[header] = null; // Allow missing alert
                            } else {
                                 entry[header] = value; // Keep as string
                            }
                        } else {
                            // Assume other metrics are numbers (handle empty strings/non-numeric as null)
                            const num = parseFloat(value);
                            if (value.trim() === '') {
                                 entry[header] = null; // Treat empty as null
                            } else if (isNaN(num)) {
                                 rowErrors.push(`Invalid non-numeric value for metric ${header}: '${value}'`);
                                 entry[header] = null; // Treat invalid number as null
                                 // Don't mark entry as invalid, just the value
                            } else {
                                 entry[header] = num;
                            }
                        }
                    }
                    
                    // Check for essential fields (Clinic, Week, Year)
                    if (!entry['Clinic'] || entry['Week'] === null || entry['Year'] === null) {
                         validEntry = false;
                         rowErrors.push("Missing essential Clinic, Week, or Year");
                    }
                    
                    if (validEntry) {
                         if (rowErrors.length > 0) {
                             // Add entry but log warnings for specific fields
                             addValidationMessage('warning', `Clinic Data CSV Warning (Row ${rowNum}, Clinic: ${entry['Clinic'] || 'N/A'}): Processed row with issues: ${rowErrors.join('; ')}.`);
                         }
                         data.push(entry);
                    } else {
                         addValidationMessage('warning', `Clinic Data CSV Warning (Row ${rowNum}): Skipped row due to critical errors: ${rowErrors.join('; ')}.`);
                         skippedRowCount++;
                    }
                }
                console.log(`Parsed ${data.length} valid data entries. Skipped ${skippedRowCount} rows.`);
                if (skippedRowCount > 0) {
                     addValidationMessage('warning', `Skipped ${skippedRowCount} rows in the Clinic Data sheet due to formatting or missing essential data (Clinic, Week, Year). See console or validation messages for details.`);
                }
                if (data.length === 0 && lines.length > 1) {
                     addValidationMessage('error', "Clinic Data CSV Error: No valid data rows could be processed. Check sheet format and ensure Clinic, Week, and Year columns are present and valid.");
                }
                return data;
            }
            
            // Parse Benchmark CSV text into an object keyed by 'Year-Week'
            function parseBenchmarkCSVData(csvText) {
                console.log("Parsing Benchmark CSV...");
                const benchmarks = {};
                const lines = csvText.trim().split(/\r?\n/);
                if (lines.length < 2) {
                    addValidationMessage('warning', "Benchmark CSV Warning: Sheet must have at least a header row and one data row. Using default benchmarks.");
                    return {};
                }
    
                const headers = lines[0].split(',').map(h => h.trim());
                console.log("Benchmark CSV Headers:", headers);
    
                // Validate headers - check for Year, Week, and expected metric/flag columns
                const requiredBaseHeaders = ['Year', 'Week'];
                const missingBase = requiredBaseHeaders.filter(h => !headers.includes(h));
                if (missingBase.length > 0) {
                     addValidationMessage('error', `Benchmark CSV Error: Missing required columns: ${missingBase.join(', ')}. Cannot process benchmarks.`);
                     return {};
                }
                
                // Exclude daily-only metrics when validating weekly benchmark CSV
                const expectedMetrics = metricsDefinition
                                          .filter(m=>!['targetVisits','googleReviews'].includes(m.id))
                                          .map(m => m.id.charAt(0).toUpperCase() + m.id.slice(1));
                            const expectedFlags = metricsDefinition
                                          .filter(m=>!['targetVisits','googleReviews'].includes(m.id))
                                          .map(m => m.id.charAt(0).toUpperCase() + m.id.slice(1) + '_HigherIsBetter');
                const missingMetrics = expectedMetrics.filter(h => !headers.includes(h));
                const missingFlags = expectedFlags.filter(h => !headers.includes(h));
                
                if (missingMetrics.length > 0) {
                     addValidationMessage('warning', `Benchmark CSV Warning: Missing benchmark value columns: ${missingMetrics.join(', ')}. Alerts for these metrics may be inaccurate.`);
                }
                 if (missingFlags.length > 0) {
                     addValidationMessage('warning', `Benchmark CSV Warning: Missing '_HigherIsBetter' flag columns: ${missingFlags.join(', ')}. Default direction (higher is better) will be assumed for these metrics.`);
                }
                const extraHeaders = headers.filter(h => !requiredBaseHeaders.includes(h) && !expectedMetrics.includes(h) && !expectedFlags.includes(h));
                 if (extraHeaders.length > 0) {
                     addValidationMessage('warning', `Benchmark CSV Warning: Found unexpected columns: ${extraHeaders.join(', ')}. These will be ignored.`);
                 }
    
                let skippedRowCount = 0;
                for (let i = 1; i < lines.length; i++) {
                    const rowNum = i + 1;
                    if (!lines[i].trim()) continue; // Skip empty lines
    
                    const values = parseCsvRow(lines[i]);
                    if (values.length !== headers.length) {
                        addValidationMessage('warning', `Benchmark CSV Warning (Row ${rowNum}): Skipped row due to incorrect number of columns (${values.length} found, ${headers.length} expected). Line: '${lines[i]}'`);
                        skippedRowCount++;
                        continue;
                    }
    
                    const entry = {};
                    let year = NaN, week = NaN;
                    let rowErrors = [];
    
                    for (let j = 0; j < headers.length; j++) {
                        const header = headers[j];
                        const value = values[j];
    
                        if (header === 'Year') {
                            year = parseInt(value);
                            if (isNaN(year) || value.trim() === '') rowErrors.push("Invalid/missing Year");
                        } else if (header === 'Week') {
                            week = parseInt(value);
                            if (isNaN(week) || value.trim() === '') rowErrors.push("Invalid/missing Week");
                        } else if (expectedMetrics.includes(header)) {
                            // Benchmark value - should be number
                            const num = parseFloat(value);
                            if (value.trim() === '') {
                                 entry[header] = null; // Allow missing benchmark
                            } else if (isNaN(num)) {
                                 rowErrors.push(`Invalid non-numeric benchmark for ${header}: '${value}'`);
                                 entry[header] = null;
                            } else {
                                 entry[header] = num;
                            }
                        } else if (expectedFlags.includes(header)) {
                            // HigherIsBetter flag - should be TRUE/FALSE
                            const flag = value.trim().toUpperCase();
                            if (flag === 'TRUE') {
                                entry[header] = true;
                            } else if (flag === 'FALSE') {
                                entry[header] = false;
                            } else {
                                 rowErrors.push(`Invalid boolean value for ${header}: '${value}' (expected TRUE or FALSE)`);
                                 entry[header] = null; // Default to null if invalid
                            }
                        }
                        // Ignore extra headers
                    }
    
                    if (!isNaN(year) && !isNaN(week)) {
                        const key = `${year}-W${week}`;
                        if (rowErrors.length > 0) {
                             addValidationMessage('warning', `Benchmark CSV Warning (Row ${rowNum}, Week: ${key}): Processed row with issues: ${rowErrors.join('; ')}.`);
                        }
                        benchmarks[key] = entry;
                    } else {
                        addValidationMessage('warning', `Benchmark CSV Warning (Row ${rowNum}): Skipped row due to missing/invalid Year or Week: ${rowErrors.join('; ')}.`);
                        skippedRowCount++;
                    }
                }
                console.log(`Parsed ${Object.keys(benchmarks).length} valid benchmark weeks. Skipped ${skippedRowCount} rows.`);
                 if (skippedRowCount > 0) {
                     addValidationMessage('warning', `Skipped ${skippedRowCount} rows in the Benchmark sheet due to formatting or missing Year/Week. See console or validation messages for details.`);
                }
                if (Object.keys(benchmarks).length === 0 && lines.length > 1) {
                     addValidationMessage('warning', "Benchmark CSV Warning: No valid benchmark rows could be processed. Default benchmarks will be used.");
                }
                return benchmarks;
            }
    
            // Process parsed data: calculate alerts, trends, group by clinic/week
            function processAndStoreData(parsedData) {
                console.log("Processing and storing data with dynamic benchmarks...");
                allClinicsData = {};
                availableWeeks = [];
                const weekSet = new Set();
                let processedEntryCount = 0;
    
                // Group data by clinic
                parsedData.forEach(entry => {
                    const clinicName = entry.Clinic;
                    if (!allClinicsData[clinicName]) {
                        allClinicsData[clinicName] = [];
                    }
                    allClinicsData[clinicName].push(entry);
                    
                    // Track available weeks
                    const weekKey = `${entry.Year}-W${entry.Week}`;
                    if (!weekSet.has(weekKey)) {
                        weekSet.add(weekKey);
                        availableWeeks.push({ year: entry.Year, week: entry.Week });
                    }
                });
    
                // Sort available weeks chronologically
                availableWeeks.sort((a, b) => {
                    if (a.year !== b.year) return a.year - b.year;
                    return a.week - b.week;
                });
                
                if (availableWeeks.length > 0) {
                    latestWeek = availableWeeks[availableWeeks.length - 1];
                    if (availableWeeks.length > 1) {
                        previousWeek = availableWeeks[availableWeeks.length - 2];
                    }
                }
                console.log("Latest Week:", latestWeek, "Previous Week:", previousWeek);
                
                // Calculate alerts and trends for each entry using dynamic benchmarks
                // Add this at (before "Object.keys(allClinicsData).forEach(...")
    function getAverageVisitsAlertLevel(current, previous) {
        if (previous == null || previous === 0 || current == null) return 'normal';
        const diffPercent = Math.abs((current - previous) / previous) * 100;
        if (diffPercent <= 5) return 'normal';
        if (diffPercent <= 10) return 'slight';
        if (diffPercent <= 20) return 'low';
        if (diffPercent <= 30) return 'high';
        return 'critical';
    }
                function findPreviousWeekData(clinicData, currentRow) {
        const currentWeek = parseInt(currentRow.Week || currentRow.week);
        const currentYear = parseInt(currentRow.Year || currentRow.year);
        let prevWeek = currentWeek - 1;
        let prevYear = currentYear;
        if (prevWeek <= 0) {
            prevYear -= 1;
            prevWeek = 52;
        }
        return clinicData.find(r =>
            parseInt(r.Week || r.week) === prevWeek &&
            parseInt(r.Year || r.year) === prevYear
        );
    }
                Object.keys(allClinicsData).forEach(clinicName => {
                    // Sort each clinic's history chronologically
                    allClinicsData[clinicName].sort((a, b) => {
                        if (a.Year !== b.Year) return a.Year - b.Year;
                        return a.Week - b.Week;
                    });
    
                    // Calculate alerts and trends
                    allClinicsData[clinicName].forEach((entry, index) => {
                        const prevEntry = index > 0 ? allClinicsData[clinicName][index - 1] : null;
                        const weekKey = `${entry.Year}-W${entry.Week}`;
                        const weeklyBenchmarks = benchmarkData[weekKey]; // Get benchmarks for this specific week
                        // Add a readable date for the Weekly Updates table (Monday of the ISO week)
                        if (!entry.date) {
                            const weekMoment = moment().year(entry.Year).isoWeek(entry.Week).startOf('isoWeek');
                            entry.date = weekMoment.format('MMM D, YYYY');
                        }
                        
                        if (!weeklyBenchmarks) {
                             addValidationMessage('warning', `Missing benchmarks for week ${weekKey}. Using fallback defaults for clinic ${clinicName}.`);
                        }
                        
                        let overallAlertCounts = { critical: 0, high: 0, low: 0, normal: 0 };
                        let trendImproving = 0;
                        let trendWorsening = 0;
                        let trendStable = 0;
    
                        // Handle AreaManagerNotesAlert first (no benchmark needed)
                        const notesAlertRaw = entry['AreaManagerNotesAlert'];
                        const notesAlert = (notesAlertRaw && ['critical', 'high', 'low', 'normal'].includes(notesAlertRaw.toLowerCase())) 
                                           ? notesAlertRaw.toLowerCase() : 'normal'; // Default to normal if missing/invalid
                        entry['areaManagerNotesAlertLevel'] = notesAlert; // Store the calculated level
                        overallAlertCounts[notesAlert]++;
                        trendStable++; // No trend for notes alert
    
                        metricsDefinition.forEach(metric => {
                            const csvHeader = metric.id.charAt(0).toUpperCase() + metric.id.slice(1);
                            const value = entry[csvHeader];
                            let higherIsBetter = true; // Initialize higherIsBetter here
    
                            if (metric.id === 'averageVisits') {
                                // Special logic for Average Number of Visits
                                let prevValue = null;
                                if (prevEntry && prevEntry[csvHeader] !== null && prevEntry[csvHeader] !== undefined && !isNaN(Number(prevEntry[csvHeader]))) {
                                    prevValue = Number(prevEntry[csvHeader]);
                                }
                                const currValue = !isNaN(Number(value)) ? Number(value) : null;
                                entry[metric.id + 'Alert'] = getAverageVisitsAlertLevel(currValue, prevValue);
    
                                // Trend: up/down/same compared to previous week
                                if (prevValue !== null && currValue !== null) {
                                    if (currValue > prevValue) {
                                        entry[metric.id + 'Trend'] = 'up';
                                    } else if (currValue < prevValue) {
                                        entry[metric.id + 'Trend'] = 'down';
                                    } else {
                                        entry[metric.id + 'Trend'] = 'same';
                                    }
                                } else {
                                    entry[metric.id + 'Trend'] = 'same';
                                }
                            } else {
                                // Get benchmark and direction from Benchma
                                const higherIsBetterFlag = weeklyBenchmarks 
                                ? weeklyBenchmarks[csvHeader + '_HigherIsBetter'] 
                                : null;
                                higherIsBetter = (higherIsBetterFlag === null || higherIsBetterFlag === undefined) ? true : higherIsBetterFlag;
                                const benchmarkValue = weeklyBenchmarks ? weeklyBenchmarks[csvHeader] : null;
                                entry[metric.id + 'Alert'] = getAlertLevel(value, benchmarkValue, higherIsBetter, metric.id);
    
                                // Calculate trend compared to previous week, taking higherIsBetter into account
                                if (
                                    prevEntry &&
                                    prevEntry[csvHeader] !== null && prevEntry[csvHeader] !== undefined &&
                                    value !== null && value !== undefined &&
                                    !isNaN(Number(prevEntry[csvHeader])) && !isNaN(Number(value))
                                ) {
                                    const prevValue = Number(prevEntry[csvHeader]);
                                    const currValue = Number(value);
                                    if (currValue > prevValue) {
                                        entry[metric.id + 'Trend'] = higherIsBetter ? 'up' : 'down';
                                    } else if (currValue < prevValue) {
                                        entry[metric.id + 'Trend'] = higherIsBetter ? 'down' : 'up';
                                    } else {
                                        entry[metric.id + 'Trend'] = 'same';
                                    }
                                } else {
                                    entry[metric.id + 'Trend'] = 'same';
                                }
                            }
    
                            // Count alerts for overall calculation
                            if (entry[metric.id + 'Alert']) {
                                overallAlertCounts[entry[metric.id + 'Alert']]++;
                            }
    
                            // Count trends for weekly trend calculation
                            if (entry[metric.id + 'Trend'] === 'up') {
                                if (metric.id === 'averageVisits') {
                                    trendImproving++; // Assume higher is always better for trend count, or adjust as needed
                                } else {
                                    higherIsBetter ? trendImproving++ : trendWorsening++;
                                }
                            } else if (entry[metric.id + 'Trend'] === 'down') {
                                if (metric.id === 'averageVisits') {
                                    trendWorsening++; // Assume lower is always worse for trend count, or adjust as needed
                                } else {
                                    higherIsBetter ? trendWorsening++ : trendImproving++;
                                }
                            } else {
                                trendStable++;
                            }
                        });
                        
                        // Determine overall alert level based on count of high/critical metrics
                        const highCriticalCount = overallAlertCounts.critical + overallAlertCounts.high;
                        if (highCriticalCount >= 8) {
                            entry.overallAlert = 'critical';
                        } else if (highCriticalCount >= 6) { // 6 or 7
                            entry.overallAlert = 'high';
                        } else if (highCriticalCount >= 3) { // 3, 4, or 5
                            entry.overallAlert = 'normal';
                        } else { // 0, 1, or 2
                            entry.overallAlert = 'low';
                        }
                        
                        // Determine weekly trend
                        if (trendImproving > trendWorsening) entry.weeklyTrend = 'improving';
                        else if (trendWorsening > trendImproving) entry.weeklyTrend = 'worsening';
                        else entry.weeklyTrend = 'stable';
                        
                        processedEntryCount++;
                    });
                
                console.log(`Data processing complete. Processed ${processedEntryCount} entries.`);
                });
            }
            
            // Get all data for a specific week
            function getDataForWeek(year, week) {
                const weekData = [];
                Object.keys(allClinicsData).forEach(clinicName => {
                    const entry = allClinicsData[clinicName].find(d => d.Year === year && d.Week === week);
                    if (entry) {
                        weekData.push(entry);
                    }
                });
                return weekData;
            }
    
            // --- Daily Data Functions ---
            // Simple CSV parser for daily metrics with specified expected headers
            function parseCsv(csvText, expectedHeaders){
                if(!csvText) return [];
                const lines = csvText.trim().split(/\r?\n/);
                if(lines.length<2) return [];
                const actualHeaders = lines[0].split(',').map(h=>h.trim());
                const headerIndex = expectedHeaders.map(h=> actualHeaders.indexOf(h));
                const data=[];
                for(let i=1;i<lines.length;i++){
                    const line=lines[i];
                    if(!line.trim()) continue;
                    const values=line.split(',');
                    const obj={};
                    expectedHeaders.forEach((h,idx)=>{
                        const colIdx = headerIndex[idx];
                        obj[h]= colIdx>=0? values[colIdx] : '';
                    });
                    data.push(obj);
                }
                return data;
            }
            async function loadDailyData() {
                try {
                    const [dailyText, dailyBenchmarkText] = await Promise.all([
                        fetchCsvText(googleSheetDailyDataUrl),
                        fetchCsvText(googleSheetDailyBenchmarkUrl)
                    ]);
                    const dailyParsed = parseCsv(dailyText, ['Date','Clinic','Target of Visits','Google Reviews','New Patients Target','No Upcoming %','Cancellation %','No Show %','Utilization %','Satisfaction Collection %']);
                    const dailyBenchmarkParsed = parseCsv(dailyBenchmarkText, ['Date','Clinic','Target of Visits','Target of Visits_HigherIsBetter','Google Reviews','Google Reviews_HigherIsBetter','New Patients Target','New Patients Target_HigherIsBetter','No Upcoming %','No Upcoming %_HigherIsBetter','Cancellation %','Cancellation %_HigherIsBetter','No Show %','No Show %_HigherIsBetter','Utilization %','Utilization %_HigherIsBetter','Satisfaction Collection %','Satisfaction Collection %_HigherIsBetter']);
                    dailyBenchmarkParsed.forEach(r=>{
                        // store exact date+clinic benchmark
                        dailyBenchmarkData[r.Date+'|'+r.Clinic] = r;
                        // keep latest benchmark per clinic as fallback
                        if(!latestDailyBenchmarkByClinic[r.Clinic] || r.Date > latestDailyBenchmarkByClinic[r.Clinic].Date){
                            latestDailyBenchmarkByClinic[r.Clinic] = r;
                        }
                        dailyBenchmarkData[r.Date+'|'+r.Clinic] = r;
                    });
                    processAndStoreDailyData(dailyParsed);
                    // Refresh Daily Numbers tab now that data is ready
                    renderDailyCurrent();
                    console.log('Daily metrics loaded');
                } catch(err){
                    console.error('Daily metrics load error',err);
                }
            }
    
            function processAndStoreDailyData(rows){
                if(!rows||rows.length===0) return;
                allClinicsDailyData = {};
                let maxDate = '';
                rows.forEach(r=>{
                    const isoDate = moment(r.Date, ['YYYY-MM-DD','MM/DD/YYYY','M/D/YYYY','DD/MM/YYYY','D/M/YYYY','MM-DD-YYYY','M-D-YYYY','DD-MM-YYYY','D-M-YYYY']).format('YYYY-MM-DD');
                    r.Date = isoDate;
                    ['Target of Visits','Google Reviews','New Patients Target'].forEach(col=>{
                        const val=parseFloat(r[col]); if(!isNaN(val)) r[col]=val;
                    });
                    const clinic=r.Clinic;
                    if(!allClinicsDailyData[clinic]) allClinicsDailyData[clinic]=[];
                    allClinicsDailyData[clinic].push(r);
                    if(r.Date>maxDate) maxDate=r.Date;
                });
                latestDailyDate=maxDate;
                Object.values(allClinicsDailyData).forEach(arr=>arr.sort((a,b)=>a.Date.localeCompare(b.Date)));
                Object.values(allClinicsDailyData).forEach(arr=>{
                    arr.forEach(row=>{
                        ['Target of Visits','Google Reviews','New Patients Target'].forEach(col=>{
                            const metricId = (col==='Target of Visits')?'targetVisits':(col==='Google Reviews')?'googleReviews':(col==='New Patients Target')?'newPatients':(col==='No Upcoming %')?'noUpcoming':(col==='Cancellation %')?'cancellation':(col==='No Show %')?'noShow':(col==='Utilization %')?'utilization':'satisfactionCollect';
                            const bench=dailyBenchmarkData[row.Date+'|'+row.Clinic]||latestDailyBenchmarkByClinic[row.Clinic]||{};
                            const higherFlag=bench[col+'_HigherIsBetter'];
                            const higherIsBetter=(higherFlag===undefined||higherFlag===null)?true:(higherFlag.toString().toLowerCase()==='true');
                            row[metricId+'Alert']=getAlertLevel(row[col], bench[col], higherIsBetter, metricId);
                        });
                    });
                });
            }
    
    
            async function fetchCsvText(url){
                const res = await fetch(url);
                if(!res.ok) throw new Error('HTTP '+res.status);
                return res.text();
            }
            // Enable UI controls after data loads
            function enableControls(){
                const df=document.getElementById('dateFilter');
                if(df) df.disabled=false;
                const exportBtn=document.querySelector('button[onclick="exportData()"]');
                if(exportBtn) exportBtn.disabled=false;
                // Explicitly enable the Historical Trends clinic dropdown
                const clinicSel = document.getElementById('clinicSelector');
                if (clinicSel) clinicSel.disabled = false;
            }
            
            // --- Rendering for Daily Numbers ---
            // Initialize daterangepicker for Daily Numbers tab (called after libraries load)
            function initializeDailyRangePicker(){
                if(typeof $ === 'undefined' || !$('#dateRangePickerDaily').daterangepicker) return;
                const picker = $('#dateRangePickerDaily');
                picker.daterangepicker({
                    opens:'left',
                    autoUpdateInput:false,
                    locale:{cancelLabel:'Clear'}
                });
                picker.on('apply.daterangepicker', function(ev, picker){
                    const start = picker.startDate.format('YYYY-MM-DD');
                    const end = picker.endDate.format('YYYY-MM-DD');
                    this.value = start + ' - ' + end;
                    renderDailyPivot();
                });
                picker.on('cancel.daterangepicker', function(){
                    this.value='';
                    renderDailyPivot();
                });
            }
            // Generate HTML for a daily metric cell similar to weekly view
            function toNumeric(val){
                if(typeof val==='number') return val;
                if(typeof val==='string'){
                    const num=parseFloat(val.replace(/[^0-9.\-]/g,''));
                    return isNaN(num)? null:num;
                }
                return null;
            }
            
            function generateDailyMetricCell(row, metricId){
                const metricNameMap={ targetVisits:'Target of Visits', googleReviews:'Google Reviews', newPatients:'New Patients Target', noUpcoming:'No Upcoming %', cancellation:'Cancellation %', noShow:'No Show %', utilization:'Utilization %', satisfactionCollect:'Satisfaction Collection %' };
                const value = (metricId==='targetVisits')? row['Target of Visits'] :
                 (metricId==='googleReviews')? row['Google Reviews'] :
                 (metricId==='newPatients')? row['New Patients Target'] :
                 (metricId==='noUpcoming')? row['No Upcoming %'] :
                 (metricId==='cancellation')? row['Cancellation %'] :
                 (metricId==='noShow')? row['No Show %'] :
                 (metricId==='utilization')? row['Utilization %'] :
                 (metricId==='satisfactionCollect')? row['Satisfaction Collection %'] :
                 (metricId==='patientWaitTime')? row['Patient Wait Time'] :
                 (metricId==='staffProductivity')? row['Staff Productivity'] :
                 (metricId==='patientSatisfaction')? row['Patient Satisfaction'] :
                 row['Revenue Growth'];
                const alert = row[metricId+'Alert']||'normal';
                const bench = dailyBenchmarkData[row.Date+'|'+row.Clinic] || latestDailyBenchmarkByClinic[row.Clinic] || {};
                let targetVal;
    switch(metricId){
        case 'targetVisits': targetVal = bench['Target of Visits'] ?? bench['TargetVisits']; break;
        case 'googleReviews': targetVal = bench['Google Reviews'] ?? bench['GoogleReviews']; break;
        case 'newPatients': targetVal = bench['New Patients Target']; break;
        case 'noUpcoming': targetVal = bench['No Upcoming %']; break;
        case 'cancellation': targetVal = bench['Cancellation %']; break;
        case 'noShow': targetVal = bench['No Show %']; break;
        case 'utilization': targetVal = bench['Utilization %']; break;
        case 'satisfactionCollect': targetVal = bench['Satisfaction Collection %']; break;
        case 'patientWaitTime': targetVal = bench['Patient Wait Time']; break;
        case 'staffProductivity': targetVal = bench['Staff Productivity']; break;
        case 'patientSatisfaction': targetVal = bench['Patient Satisfaction']; break;
        case 'revenueGrowth': targetVal = bench['Revenue Growth']; break;
    }
                let displayVal = value;
                if(typeof displayVal === 'string' && displayVal.trim().endsWith('%')){
                    displayVal = displayVal.trim().slice(0,-1);
                }
                const displayValue = (displayVal===null||displayVal===undefined||displayVal==='') ? 'N/A' : displayVal;
                let targetDisplay = targetVal;
                if(typeof targetDisplay === 'string' && targetDisplay.trim().endsWith('%')){
                    targetDisplay = targetDisplay.trim().slice(0,-1); // remove trailing % if present
                }
                const targetText = (targetDisplay===null||targetDisplay===undefined||targetDisplay==='') ? 'Target: N/A' : `Target: ${targetDisplay}`;
                // Get trend indicator for the metric (if available)
    const trend = row[metricId + 'Trend'] || '';
    const arrow = getTrendArrow(trend);
    let arrowSpan = '';
                const metricHeader = metricToColumn[metricId];
                const tbody=document.getElementById('dailyTableBody');
                const thead=document.getElementById('dailyTableHead');
                if(!tbody||!thead) return;
                tbody.innerHTML='';
                thead.innerHTML='';
                if(Object.keys(allClinicsDailyData).length===0){
                    tbody.innerHTML='<tr><td style="text-align:center;">No daily data</td></tr>';return;
                }
                // Collect dates
                let dateSet=new Set();
                Object.values(allClinicsDailyData).forEach(arr=>arr.forEach(r=>dateSet.add(r.Date)));
                let dates=[...dateSet].sort((a,b)=>a.localeCompare(b));
                // Filter by selected range if provided, else last 7 days
                const rangeVal = document.getElementById('dateRangePickerDaily').value;
                let startDate,endDate;
                if(rangeVal && rangeVal.includes(' - ')){
                    const [sRaw,eRaw]=rangeVal.split(' - ');
                    startDate=sRaw.trim();
                    endDate=eRaw.trim();
                }
                if(startDate && endDate){
                    dates = dates.filter(d=> d>=startDate && d<=endDate);
                } else {
                    // default to last 7 days
                    dates = dates.slice(-7);
                }
                // header row
                let headerRow='<tr><th>Clinic</th><th>Overall Alert</th>';
                dates.forEach(d=>{headerRow+=`<th class="pivot-date">${moment(d).format('MMM D, YYYY')}</th>`;});
                headerRow+='</tr>';
                thead.innerHTML=headerRow;
                // clinics rows
                const clinics=Object.keys(allClinicsDailyData).sort((a,b)=>a.localeCompare(b));
                clinics.forEach(clinic=>{
                    let rowHtml=`<tr><td class="clinic-name">${clinic}</td>`;
                    let achievedSum=0, targetSum=0, higherIsBetter=true;
                    let dateCells='';
                    dates.forEach(d=>{
                        const rec=allClinicsDailyData[clinic].find(r=>r.Date===d);
                        if(rec){
                            dateCells+= generateDailyMetricCell(rec, metricId);
                            const benchRow = dailyBenchmarkData[rec.Date+'|'+rec.Clinic] || latestDailyBenchmarkByClinic[rec.Clinic] || {};
                            const benchVal = benchRow[metricHeader];
                            const benchNumeric = toNumeric(benchVal);
                            const achievedNumeric = toNumeric(rec[metricHeader]);
                            if(benchNumeric!==null && achievedNumeric!==null){
                                targetSum += benchNumeric;
                                achievedSum += achievedNumeric;
                            }
                            const hFlag = benchRow[metricHeader+'_HigherIsBetter'];
                            if(hFlag!==undefined&&hFlag!==null) higherIsBetter = (hFlag.toString().toLowerCase()==='true');
                        } else {
                            dateCells+='<td>N/A</td>';
                        }
                    });
                    let overall='low';
                    if(targetSum>0){
                        overall = getAlertLevel(achievedSum, targetSum, higherIsBetter, metricId);
                    }
                    rowHtml+=`<td><span class=\"alert-badge alert-${overall}\">${overall.toUpperCase()}</span></td>`+dateCells+'</tr>';
                    tbody.innerHTML+=rowHtml;
                });
            }
    // OLD renderDailyCurrent removed for pivot
                /* const selectedDateRaw = document.getElementById('dateFilter')?.value;
                const selectedDate = selectedDateRaw ? moment(selectedDateRaw, ['YYYY-MM-DD','MM/DD/YYYY','M/D/YYYY']).format('YYYY-MM-DD') : '';
    
                const tbody = document.getElementById('dailyTableBody');
                const thead = document.getElementById('dailyTableHead');
                if(!tbody) return;
    
                // Build table header (Clinic as first column; percentage columns)
                if(thead){
                    thead.innerHTML = '<tr><th>Clinic</th><th>Target %</th><th>Achieved %</th></tr>';
                }
                tbody.innerHTML = '';
    
                // Collect rows (limit to last 7 days overall like before)
                let rows=[];
                Object.keys(allClinicsDailyData).forEach(clinic=>{
                    allClinicsDailyData[clinic].forEach(r=>rows.push(r));
                });
    
                rows.sort((a,b)=> b.Date.localeCompare(a.Date));
    
                // Keep within last 7 overall days
                const cutoffDate = moment(latestDailyDate).subtract(6,'days').format('YYYY-MM-DD');
                rows = rows.filter(r=> r.Date>=cutoffDate);
    
                if(selectedDate){
                    rows = rows.filter(r=> r.Date===selectedDate);
                }
    
                // Group by date
                const grouped = {};
                rows.forEach(r=>{
                    if(!grouped[r.Date]) grouped[r.Date]=[];
                    grouped[r.Date].push(r);
                });
    
                const orderedDates = Object.keys(grouped).sort((a,b)=> b.localeCompare(a));
                orderedDates.forEach(date=>{
                    // Date header row spanning all columns
                    const dateHeader=document.createElement('tr');
                    dateHeader.className='date-header';
                    dateHeader.innerHTML = `<td colspan="3" style="background:#6c63ff;color:white;font-weight:bold;position:sticky;left:0;">${moment(date).format('MMM D, YYYY')}</td>`;
                    tbody.appendChild(dateHeader);
    
                    // Sort clinics alphabetically for this date
                    grouped[date].sort((a,b)=>a.Clinic.localeCompare(b.Clinic)).forEach(r=>{
                        const tr=document.createElement('tr');
                        tr.innerHTML = `<td class="clinic-name">${r.Clinic}</td>
                            ${generateDailyMetricCell(r,'targetVisits')}
                            ${generateDailyMetricCell(r,'googleReviews')}`;
                        tbody.appendChild(tr);
                    });
                });
            }
    // --- end of updated renderDailyPivot ---
    */
            // Compatibility wrapper for legacy calls
            function renderDailyCurrent(){
                renderDailyPivot();
            }
    
    
    
                /* duplicate obsolete block removed
    // if(!body) return;
                // Build table header if empty
                if(body.innerHTML===''){
                    const thead=document.getElementById('dailyTableHead');
                    if(thead){
                        thead.innerHTML='<tr><th>Date</th><th>Clinic</th><th>Target Visits</th><th>Google Reviews</th></tr>';
                    }
                }
                body.innerHTML='';
                if(Object.keys(allClinicsDailyData).length===0){
                    body.innerHTML='<tr><td colspan="4" style="text-align:center;">No daily data</td></tr>';return;
                }
                const rows=[];
                Object.keys(allClinicsDailyData).forEach(clinic=>{
                    allClinicsDailyData[clinic].forEach(r=>rows.push(r));
                });
                // Keep only rows within last 7 days overall
                rows.sort((a,b)=> b.Date.localeCompare(a.Date));
                let candidateRows=rows;
                if(selectedDate){
                    candidateRows=candidateRows.filter(r=>r.Date===selectedDate);
                }
                const cutoffDate = moment(latestDailyDate).subtract(6,'days').format('YYYY-MM-DD');
                const filtered = candidateRows.filter(r=> r.Date>=cutoffDate);
                filtered.forEach(r=>{
            const tr=document.createElement('tr');
            tr.innerHTML=`<td>${r.Date}</td><td class="clinic-name">${r.Clinic}</td>
                ${generateDailyMetricCell(r,'targetVisits')}
                ${generateDailyMetricCell(r,'googleReviews')}`;
            body.appendChild(tr);
        });
    }
            
            */
    // --- Helper Functions ---
    
            // Function to get trend arrow symbol
            function getTrendArrow(trend) {
                switch (trend) {
                    case 'up': return '▲';
                    case 'down': return '▼';
                    case 'same': return '▬';
                    default: return '';
                }
            }
    
            // Helper function to determine alert level using DYNAMIC benchmarks and custom deviation thresholds
            // higherIsBetter might not be needed for this logic
            // Handle missing data or missing benchmarks gracefully
            function getAlertLevel(value, target, higherIsBetter, metricId) { 
                if (value === null || value === undefined) return 'normal'; 
                if (target === null || target === undefined) {
                     console.warn(`Missing benchmark for metric '${metricId}' for the relevant week. Alert level defaulted to 'normal'.`); // Log to console instead of UI
                     return 'normal'; 
                }
    
                const benchmarkValue = parseFloat(target);
        const metricValue = parseFloat(value);
        if (isNaN(benchmarkValue) || isNaN(metricValue) || benchmarkValue === 0) {
            return 'normal';
        }
    
        // List of metrics to apply "only alert if higher than target"
        const onlyAlertIfHigher = ['cancel', 'noShow', 'noUpcoming', 'directAccess'];
    
        // For these metrics, only show alert if value > target
        if (onlyAlertIfHigher.includes(metricId)) {
            if (metricValue <= benchmarkValue) {
                return 'normal';
            }
            // Only calculate alert if higher than target
            const deviationPercent = ((metricValue - benchmarkValue) / benchmarkValue) * 100;
            if (deviationPercent <= 5) {
                return 'normal';
            } else if (deviationPercent <= 10) {
                return 'slight';
            } else if (deviationPercent <= 20) {
                return 'low';
            } else if (deviationPercent <= 30) {
                return 'high';
            } else {
                return 'critical';
            }
        }
    
        // Default logic for other metrics
            // Default logic for other metrics, using higherIsBetter
        let deviationPercent = 0;
        let isNegative = false;
    
        if (higherIsBetter === true) {
            deviationPercent = ((benchmarkValue - metricValue) / benchmarkValue) * 100;
            isNegative = metricValue < benchmarkValue; // Bad if below target
        } else if (higherIsBetter === false) {
            deviationPercent = ((metricValue - benchmarkValue) / benchmarkValue) * 100;
            isNegative = metricValue > benchmarkValue; // Bad if above target
        } else {
            deviationPercent = Math.abs((metricValue - benchmarkValue) / benchmarkValue) * 100;
            isNegative = deviationPercent > 0;
        }
        if (!isNegative || deviationPercent <= 5) {
            return 'normal';
        } else if (deviationPercent <= 10) {
            return 'slight';
        } else if (deviationPercent <= 20) {
            return 'low';
        } else if (deviationPercent <= 30) {
            return 'high';
        } else {
            return 'critical';
        }
    }
            
            // Helper to get color based on alert level
            function getAlertColor(alertLevel) {
                switch(alertLevel) {
                    case 'critical': return '#e74c3c';
                    case 'high': return '#f39c12';
                    case 'low': return '#f1c40f';
                    case 'normal': return '#27ae60';
                    default: return '#95a5a6'; // Default grey
                }
            }
            
            // --- Validation Message Handling ---
            function addValidationMessage(type, message) {
                validationMessages.push({ type, message });
                console.log(`Validation (${type}): ${message}`);
            }
    
            function displayValidationMessages() {
                const section = document.getElementById('validationSection');
                const list = document.getElementById('validationMessages');
                if (!section || !list) return;
    
                list.innerHTML = ''; // Clear previous messages
                if (validationMessages.length === 0) {
                    list.innerHTML = '<li class="success">Data and benchmarks loaded successfully with no issues detected.</li>';
                } else {
                    validationMessages.forEach(msg => {
                        const item = document.createElement('li');
                        item.classList.add(msg.type); // Add class 'error', 'warning', or 'success'
                        item.textContent = msg.message;
                        list.appendChild(item);
                    });
                }
                section.style.display = 'block'; // Show the section
            }
    
            // --- UI Initialization & Update Functions ---
            
            function initializeDatePickers() {
                 $(function() {
                    $('#dateRangePicker').daterangepicker({
                        startDate: dateRange.start,
                        endDate: dateRange.end,
                        opens: 'left',
                        ranges: {
                           'Last 4 Weeks': [moment().subtract(4, 'weeks'), moment()],
                           'Last 8 Weeks': [moment().subtract(8, 'weeks'), moment()],
                           'Last 3 Months': [moment().subtract(3, 'months'), moment()],
                           'Last 6 Months': [moment().subtract(6, 'months'), moment()],
                           'Year to Date': [moment().startOf('year'), moment()],
                           'Last Year': [moment().subtract(1, 'year').startOf('year'), moment().subtract(1, 'year').endOf('year')]
                        }
                    }, function(start, end, label) {
                        dateRange.start = start;
                        dateRange.end = end;
                        updateHistoricalCharts();
                    });
    
                    $('#compareRangePicker1, #compareRangePicker2').daterangepicker({
                        singleDatePicker: false,
                        opens: 'left',
                         ranges: {
                           'Last Week': [moment().subtract(1, 'week').startOf('week'), moment().subtract(1, 'week').endOf('week')],
                           'Last Month': [moment().subtract(1, 'month').startOf('month'), moment().subtract(1, 'month').endOf('month')],
                           'Last Quarter': [moment().subtract(1, 'quarter').startOf('quarter'), moment().subtract(1, 'quarter').endOf('quarter')]
                        }
                    });
                });
            }
            
            // Populate metric selector buttons in historical tab
            function populateMetricSelector() {
                const selectorDiv = document.getElementById('metricSelector');
                selectorDiv.innerHTML = ''; // Clear existing
                metricsDefinition.forEach((metric, index) => {
                    // if (metric.type === 'text') return; // Already filtered in definition
                    const button = document.createElement('button');
                    button.dataset.metric = metric.id;
                    button.textContent = metric.name;
                    if (metric.id === selectedMetric) {
                        button.classList.add('active');
                    }
                    button.addEventListener('click', function() {
                        selectMetric(this.dataset.metric);
                    });
                    selectorDiv.appendChild(button);
                });
            }
            
            // Populate time period filter (Current/Previous Week)
            function populateTimePeriodFilter() {
                const selector = document.getElementById('timePeriodFilter');
                selector.innerHTML = ''; // Clear existing
                // Add "All Weeks" option so users can view data across all weeks
                const optionAllWeeks = document.createElement('option');
                optionAllWeeks.value = 'all';
                optionAllWeeks.textContent = 'All Weeks';
                selector.appendChild(optionAllWeeks)
                
                if (latestWeek.year > 0) {
                     const optionCurrent = document.createElement('option');
                     optionCurrent.value = 'current';
                     optionCurrent.textContent = `Current (W${latestWeek.week}, ${latestWeek.year})`;
                     selector.appendChild(optionCurrent);
                }
                if (previousWeek.year > 0) {
                     const optionPrevious = document.createElement('option');
                     optionPrevious.value = 'previous';
                     optionPrevious.textContent = `Previous (W${previousWeek.week}, ${previousWeek.year})`;
                     selector.appendChild(optionPrevious);
                }
                selector.value = 'current'; // Default to current
            }
    
            // Populate clinic filter options in all relevant dropdowns
            function populateClinicOptions() {
                const clinicNames = Object.keys(allClinicsData).sort();
                const selectors = [
                    document.getElementById('clinicFilter'),
                    document.getElementById('clinicSelector'),
                    document.getElementById('compareClinicSelectorW2W'),
                    document.getElementById('compareClinicSelector4W'),
                    document.getElementById('compareClinicSelectorCR')
                ];
                
                selectors.forEach(selector => {
                    if (!selector) return;
                    const currentValue = selector.value;
                    // Clear existing options except the first one ('All Clinics')
                    while (selector.options.length > 1) {
                        selector.remove(1);
                    }
                    // Add clinic options
                    clinicNames.forEach(name => {
                        const option = document.createElement('option');
                        option.value = name;
                        option.textContent = name;
                        selector.appendChild(option);
                    });
                    // Restore previous selection if possible
                    if (clinicNames.includes(currentValue)) {
                        selector.value = currentValue;
                    } else {
                        selector.value = 'all'; // Default to 'all'
                    }
                });
            }
    
            // Populate week selector options for comparison tab
            function populateWeekSelectors() {
                const selectors = [
                    document.getElementById('compareWeek1'),
                    document.getElementById('compareWeek2'),
                    document.getElementById('compareWeek3'),
                    document.getElementById('compareWeek4')
                ];
                
                selectors.forEach((selector, index) => {
                    if (!selector) return;
                    selector.innerHTML = ''; // Clear existing options
                    availableWeeks.forEach(week => {
                        const option = document.createElement('option');
                        option.value = `${week.year}-W${week.week}`;
                        option.textContent = moment().year(week.year).isoWeek(week.week).startOf('isoWeek').format('MMM D, YYYY');
                        selector.appendChild(option);
                    });
                    // Set default selected week (e.g., last 4 weeks)
                    const defaultIndex = Math.max(0, availableWeeks.length - 1 - index);
                     if (availableWeeks.length > defaultIndex) {
                        selector.selectedIndex = defaultIndex;
                    }
                });
            }
    
            // Update summary cards based on the provided data array
            function updateSummaryCards(data) {
                const summaryCardsContainer = document.getElementById('summaryCards');
                if (!data || data.length === 0) {
                     summaryCardsContainer.innerHTML = '<div class="summary-card"><p>No data available for the selected period/filters.</p></div>';
                     // return;
                }
                
                const alertCounts = { critical: 0, high: 0, low: 0, normal: 0 };
                data.forEach(clinic => {
                     alertCounts[clinic.overallAlert]++;
                });
                
                const summaryCardsHTML = `
                    <div class="summary-card">
                        <h3>Critical Alerts</h3>
                        <div class="number critical">${alertCounts.critical}</div>
                        <div>Require Immediate Action</div>
                    </div>
                    <div class="summary-card">
                        <h3>High Alerts</h3>
                        <div class="number high">${alertCounts.high}</div>
                        <div>Need Attention</div>
                    </div>
                    <div class="summary-card">
                        <h3>Low Alerts</h3>
                        <div class="number low">${alertCounts.low}</div>
                        <div>Monitor Closely</div>
                    </div>
                    <div class="summary-card">
                        <h3>Normal Performance</h3>
                        <div class="number normal">${alertCounts.normal}</div>
                        <div>Meeting Targets</div>
                    </div>
                `;
                summaryCardsContainer.innerHTML = summaryCardsHTML;
            }
            
            // Update the 'Last Updated' timestamp
            function updateLastUpdated() {
                const lastUpdatedDiv = document.getElementById('lastUpdated');
                if (latestWeek.year > 0) {
                     const currentMoment = moment();
                     lastUpdatedDiv.textContent = `Data Loaded: ${currentMoment.format('MMM D, YYYY HH:mm')} | Latest Data: Week ${latestWeek.week}, ${latestWeek.year}`;
                } else {
                     lastUpdatedDiv.textContent = 'No data loaded.';
                }
            }
    
            // Populate table with data
            function populateTable(data) {
                const tbody = document.getElementById('tableBody');
                const title = document.getElementById('tableTitle');
                if (!tbody) { console.error("Table body not found!"); return; }
                tbody.innerHTML = ''; // Clear previous rows
                
                const timePeriod = document.getElementById('timePeriodFilter').value;
                const weekInfo = (timePeriod === 'current' && latestWeek.year > 0) ? latestWeek : previousWeek;
                title.textContent = `Clinic Performance Overview - Week ${weekInfo.week || 'N/A'}, ${weekInfo.year || 'N/A'}`;
                
                if (!data || data.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="23" style="text-align: center;">No data available for the selected filters.</td></tr>'; // Updated colspan
                    // return;
                }
    
                data.forEach(clinic => {
                    const row = document.createElement('tr');
                    const notesAlert = clinic['areaManagerNotesAlertLevel'] || 'normal'; // Use processed level
                    
                    row.innerHTML = `
        <td class="clinic-name">${clinic.Clinic}</td>
        <td>${clinic.date || ''}</td>
        <!-- AreaManagerNotes removed -->
        <td><span class="alert-badge alert-${notesAlert}">${notesAlert.toUpperCase()}</span></td>
        ${generateMetricCell(clinic, 'newPatients')}
        ${generateMetricCell(clinic, 'visitsTarget')}
        ${generateMetricCell(clinic, 'dailyDistribution')}
        ${generateMetricCell(clinic, 'utilization')}
        ${generateMetricCell(clinic, 'retention2nd')}
        ${generateMetricCell(clinic, 'retention5th')}
        ${generateMetricCell(clinic, 'retention10th')}
        ${generateMetricCell(clinic, 'retention15th')}
        ${generateMetricCell(clinic, 'cancel')}
        ${generateMetricCell(clinic, 'noShow')}
        ${generateMetricCell(clinic, 'noUpcoming')}
        ${generateMetricCell(clinic, 'units')}
        ${generateMetricCell(clinic, 'insuranceCoding')}
        ${generateMetricCell(clinic, 'supportiveCoding')}
        ${generateMetricCell(clinic, 'averageVisits')}
        ${generateMetricCell(clinic, 'confirmation')}
        ${generateMetricCell(clinic, 'directAccess')}
        ${generateMetricCell(clinic, 'surveyCollection')}
        ${generateMetricCell(clinic, 'satisfaction')}
        <td class="metric-value">
            <span class="alert-badge alert-${clinic.overallAlert}">${clinic.overallAlert.toUpperCase()}</span>
        </td>
        <td class="metric-value">
            ${clinic.weeklyTrend || 'N/A'}
        </td>
        <td>
            <button class="action-button" onclick="showDetails('${clinic.Clinic}')">Details</button>
        </td>
    */`;
                    tbody.appendChild(row);
                });
            }
            
            // Enable controls after data load
            function enableControls() {
                document.querySelectorAll('.controls select, .controls input, .controls button, .view-toggle button, .tab-buttons button, .comparison-controls select, .comparison-controls input, .comparison-controls button, #dateRangePicker, #compareRangePicker1, #compareRangePicker2').forEach(el => el.disabled = false);
                // Explicitly enable the Historical Trends clinic dropdown
                const clinicSel = document.getElementById('clinicSelector');
                if (clinicSel) clinicSel.disabled = false;
            }
            
            // Disable controls on error or before data load
            function disableControls() {
                 document.querySelectorAll('.controls select, .controls input, .controls button, .view-toggle button, .tab-buttons button, .comparison-controls select, .comparison-controls input, .comparison-controls button, #dateRangePicker, #compareRangePicker1, #compareRangePicker2').forEach(el => el.disabled = true);
            }
    
            // --- Event Handlers & Filters ---
    
            // Filter table based on selected alert level, clinic, and search input
            // Filter table based on selected alert level, clinic, search input, and date
    function filterTable() {
        const selectedRaw  = document.getElementById('dateFilter').value; // browser-locale string or ISO
        const selectedDate = selectedRaw ? moment(selectedRaw, ['YYYY-MM-DD','MM/DD/YYYY','M/D/YYYY']).format('YYYY-MM-DD') : '';
        if (availableWeeks.length === 0) return; // No data yet
    
        const alertFilter   = document.getElementById('alertFilter').value;
        const clinicFilter  = document.getElementById('clinicFilter').value;
        const searchInput   = document.getElementById('searchInput').value.toLowerCase();
        const timePeriod    = document.getElementById('timePeriodFilter').value;
    
        // Decide base dataset: if a specific date is chosen, search ALL weeks; otherwise honour the time-period selector
        let baseData = [];
        if (selectedDate || timePeriod==='all') {
            // Flatten all weeks
            Object.values(allClinicsData).forEach(arr => { if(Array.isArray(arr)) baseData.push(...arr); });
        } else {
            baseData = (timePeriod === 'current')
                ? getDataForWeek(latestWeek.year, latestWeek.week)
                : getDataForWeek(previousWeek.year, previousWeek.week);
        }
    
        displayedData = baseData.filter(clinic => {
            const matchesAlert  = alertFilter === 'all' || clinic.overallAlert === alertFilter;
            const matchesClinic = clinicFilter === 'all' || clinic.Clinic === clinicFilter;
            const matchesSearch = clinic.Clinic.toLowerCase().includes(searchInput);
    
            let matchesDate = true;
            if(selectedDate){
                // Attempt exact date match first (for daily views or if weekly row stores explicit date)
                const rowDateRaw = clinic.Date || clinic.date || '';
                const rowDateIso = rowDateRaw ? moment(rowDateRaw, ['YYYY-MM-DD','MM-DD-YYYY','MM/DD/YYYY','M/D/YYYY']).format('YYYY-MM-DD') : '';
                matchesDate = (rowDateIso === selectedDate);
                if(!matchesDate && clinic.Year && clinic.Week){
                    // If weekly entry: compare ISO week/year of selected date
                    const selMoment = moment(selectedDate, 'YYYY-MM-DD');
                    const selYear = selMoment.isoWeekYear();
                    const selWeek = selMoment.isoWeek();
                    matchesDate = (selYear == clinic.Year && selWeek == clinic.Week);
                }
            }
    
            return matchesAlert && matchesClinic && matchesSearch && matchesDate;
        });
                // Re-populate table and card view based on filtered data
                if (currentView === 'table') {
                     populateTable(displayedData);
                } else {
                     populateCardView(displayedData);
                }
               
                // Update summary cards based on the filtered data
                updateSummaryCards(displayedData);
            }
    
            // Change time period (Current Week / Previous Week)
            function changeTimePeriod() {
                 if (availableWeeks.length === 0) return;
                 const timePeriod = document.getElementById('timePeriodFilter').value;
                 if(timePeriod === 'current') {
                     currentWeekData = getDataForWeek(latestWeek.year, latestWeek.week);
                 } else if(timePeriod === 'previous') {
                     currentWeekData = getDataForWeek(previousWeek.year, previousWeek.week);
                 } else {
                     // 'all' selected – don't restrict currentWeekData; it will be derived in filterTable
                     currentWeekData = [];
                 }
                 filterTable(); // Re-apply filters for the new time period
            }
    

            // --- Utility Function: Populate Card View ---
function populateCardView(data) {
    const container = document.getElementById('cardView');
    if (!container) return;
    container.innerHTML = '';
    if (!data || data.length === 0) {
        container.innerHTML = '<p>No data available for selected filters.</p>';
        return;
    }
    data.forEach(clinic => {
        const card = document.createElement('div');
        card.className = 'summary-card clinic-card';
        const alertLevel = clinic.overallAlert || 'normal';
        const trendText = clinic.weeklyTrend || 'N/A';
        const notesAlert = clinic.areaManagerNotesAlertLevel || 'N/A';
        card.innerHTML = `
            <h2 class="status-text alert-${alertLevel}">${alertLevel.toUpperCase()}</h2>
            <h3>${clinic.Clinic}</h3>
            <div class="metric-line">Overall Status</div>
            <div class="metric-line">Trend: ${trendText}</div>
            <div class="metric-line">Notes Alert: ${notesAlert.toUpperCase()}</div>
            <button class="action-button" onclick="showDetails('${clinic.Clinic}')">Details</button>`;
        container.appendChild(card);
    });
}
/* STRAY DUPLICATE BLOCK COMMENTED OUT

    const arrow = getTrendArrow(trend);
    let arrowSpan='';
    if(arrow){
        arrowSpan=`<span class="trend-arrow trend-${trend||'same'}">${arrow}</span>`;
    }
    // Determine target: prefer benchmarkData for entry's week, fallback to in-row target column
    const benchKey = (typeof benchmarkData!=='undefined') ? `${entry.Year}-W${entry.Week}` : null;
    let benchTarget;
    if(benchKey && benchmarkData[benchKey]){
        benchTarget = benchmarkData[benchKey][csvHeader];
    }
    const targetVal = (benchTarget!==undefined && benchTarget!==null && benchTarget!=='') ? benchTarget : target;

    let targetText='Target: N/A';
    if(targetVal!==undefined && targetVal!==null && targetVal!==''){
        let tDisplay = targetVal;
        if(metricMeta.type==='percentage'){
            const n=parseFloat(targetVal);
            tDisplay = isNaN(n)? targetVal : n.toFixed(1)+'%';
        }
        targetText = `Target: ${tDisplay}`;
    }

    return `<td class="metric-value">
                <div>${display} ${arrowSpan}</div>
                <span class="alert-badge alert-${alertLevel}">${alertLevel.toUpperCase()}</span>
                <div class="deviation">${targetText}</div>
            </td>`;
*/

// Toggle between Table and Card view
            function toggleView(view) {
                currentView = view;
                const tableView = document.getElementById('tableView');
                const cardView = document.getElementById('cardView');
                const viewButtons = document.querySelectorAll('.view-toggle button');
    
                if (view === 'table') {
                    tableView.style.display = 'block';
                    cardView.style.display = 'none';
                    viewButtons[0].classList.add('active');
                    viewButtons[1].classList.remove('active');
                    populateTable(displayedData); // Ensure table is populated
                } else {
                    tableView.style.display = 'none';
                    cardView.style.display = 'grid'; // Use grid for card layout
                    viewButtons[0].classList.remove('active');
                    viewButtons[1].classList.add('active');
                    populateCardView(displayedData); // Ensure cards are populated
                }
            }
    
            // Switch between main tabs (Current Data, Historical, Comparison)
            function switchTab(event, tabId) {
                const tabContents = document.querySelectorAll('.tab-content');
                const tabButtons = document.querySelectorAll('.tab-button');
    
                tabContents.forEach(content => content.classList.remove('active'));
                tabButtons.forEach(button => button.classList.remove('active'));
    
                document.getElementById(tabId).classList.add('active');
                event.currentTarget.classList.add('active');
    
                // If switching to daily tab, refresh its data view
                if(tabId === 'dailyTab'){
                    if(!document.getElementById('dateRangePickerDaily').value){
                        initializeDailyRangePicker();
                    }
                    renderDailyCurrent();
                }
                // If switching to historical tab, update charts
                if (tabId === 'historicalTrends' && availableWeeks.length > 0) {
                    updateHistoricalCharts();
                }
            }
    
            // Show clinic details panel
            function showDetails(clinicName) {
                const panel = document.getElementById('detailsPanel');
                const title = document.getElementById('detailsTitle');
                const content = document.getElementById('detailsContent');
                
                const timePeriod = document.getElementById('timePeriodFilter').value;
                const sourceData = (timePeriod === 'current') ? getDataForWeek(latestWeek.year, latestWeek.week) : getDataForWeek(previousWeek.year, previousWeek.week);
                const clinicData = sourceData.find(c => c.Clinic === clinicName);
    
                if (!clinicData) {
                    content.innerHTML = '<p>Clinic data not found for the selected period.</p>';
                    panel.classList.add('open');
                    // return;
                }
    
                title.textContent = `${clinicName} - Details (Week ${clinicData.Week}, ${clinicData.Year})`;
                const notesAlert = clinicData['areaManagerNotesAlertLevel'] || 'normal';
                const weekKey = `${clinicData.Year}-W${clinicData.Week}`;
                const weeklyBenchmarks = benchmarkData[weekKey];
                
                let detailsHTML = `<h4>Overall Alert: <span class="alert-badge alert-${clinicData.overallAlert}">${clinicData.overallAlert.toUpperCase()}</span></h4>`;
                // AreaManagerNotes removed
                detailsHTML += `<p><strong>Notes Alert Level:</strong> <span class="alert-badge alert-${notesAlert}">${notesAlert.toUpperCase()}</span></p>`;
                detailsHTML += `<p><strong>Weekly Trend:</strong> ${clinicData.weeklyTrend || 'N/A'}</p>`;
                detailsHTML += `<hr style="margin: 15px 0;">`;
                detailsHTML += `<h4>Metric Details:</h4>`;
                detailsHTML += `<div class="metric-grid">`;
    
                metricsDefinition.forEach(metric => {
                     // if (metric.id === 'areaManagerNotes') return; // Already removed
    
                     const csvHeader = metric.id.charAt(0).toUpperCase() + metric.id.slice(1);
                     const value = clinicData[csvHeader];
                     const alert = clinicData[metric.id + 'Alert'] || 'normal';
                     const trend = clinicData[metric.id + 'Trend'] || 'same';
                     const target = weeklyBenchmarks ? weeklyBenchmarks[csvHeader] : null;
                     let displayValue = 'N/A';
                     let targetText = '';
    
                     if (value !== null && value !== undefined) {
                         displayValue = metric.type === 'percentage' ? `${value}%` : value;
                     }
                     if (target !== null && target !== undefined) {
                         targetText = metric.type === 'percentage' ? `Target: ${target}%` : `Target: ${target}`;
                     } else {
                         targetText = 'Target: N/A';
                     }
    
                     detailsHTML += `
                        <div class="metric-item">
                            <strong>${metric.name}:</strong> ${displayValue}
                            <span class="alert-badge alert-${alert}" style="float: right;">${alert.toUpperCase()}</span>
                            <br>
                            <span style="font-size: 0.9em; color: #555;">
                                Trend: <span class="trend-arrow trend-${trend}">${getTrendArrow(trend)}</span> ${trend}
                                | ${targetText}
                            </span>
                        </div>
                     `;
                });
    
                detailsHTML += `</div>`;
                detailsHTML += `<hr style=\"margin: 15px 0;\"><h4 id=\"detailTrendHeader\">Historical Trend (${metricsDefinition.find(m=>m.id===selectedMetric)?.name || selectedMetric}):</h4>`;
                detailsHTML += `<div id="detailTrendChart" style="width: 100%; height: 250px;">Loading chart...</div>`;
    
                content.innerHTML = detailsHTML;
                panel.classList.add('open');
    
                // Draw chart in the details panel after it's open
                setTimeout(() => drawDetailTrendChart(clinicName), 50); // Small delay for rendering
            }
    
            // Close clinic details panel
            function closeDetails() {
                document.getElementById('detailsPanel').classList.remove('open');
            }
    
            // --- Historical Data Tab Functions ---
    
            // Update charts based on selected clinic and metric
            function updateHistoricalCharts() {
                if (!google.visualization || !google.visualization.DataTable) {
                     console.warn("Google Visualization not ready yet.");
                     // return;
                }
                if (Object.keys(allClinicsData).length === 0) {
                     document.getElementById('trendChart').innerHTML = '<p>Load data first.</p>';
                     document.getElementById('comparisonChart').innerHTML = '';
                     // return;
                }
                
                console.log(`Updating historical charts for Clinic: ${selectedClinic}, Metric: ${selectedMetric}`);
                showLoading("Updating charts...");
                
                const clinicHistory = selectedClinic === 'all' 
                    ? averageHistoricalData() // Get averaged data across all clinics
                    : allClinicsData[selectedClinic];
    
                if (!clinicHistory || clinicHistory.length === 0) {
                    document.getElementById('trendChart').innerHTML = '<p>No historical data available for this selection.</p>';
                    document.getElementById('comparisonChart').innerHTML = '';
                    hideLoading();
                    // return;
                }
    
                // Filter data by date range picker
                const filteredData = clinicHistory.filter(d => {
                    // Use Year and Week from data
                    const weekMoment = moment().year(d.Year).isoWeek(d.Week);
                    return weekMoment.isBetween(dateRange.start, dateRange.end, 'day', '[]'); // Inclusive
                }).sort((a, b) => {
                     if (a.Year !== b.Year) return a.Year - b.Year;
                     return a.Week - b.Week;
                }); // Ensure sorted by week
    
                if (filteredData.length === 0) {
                    document.getElementById('trendChart').innerHTML = '<p>No data available for the selected date range.</p>';
                     document.getElementById('comparisonChart').innerHTML = '';
                     hideLoading();
                    // return;
                }
    
                // Prepare data for Trend Chart (Selected Metric over Time)
                const trendData = new google.visualization.DataTable();
                trendData.addColumn('string', 'Week');
                const metricDef = metricsDefinition.find(m => m.id === selectedMetric);
                const metricName = metricDef?.name || selectedMetric;
                const csvHeader = selectedMetric.charAt(0).toUpperCase() + selectedMetric.slice(1);
                trendData.addColumn('number', metricName);
                trendData.addColumn({type: 'string', role: 'tooltip', 'p': {'html': true}});
                trendData.addColumn({type: 'string', role: 'style'}); // For alert colors
    
                filteredData.forEach(d => {
                    const weekLabel = d.date || moment().year(d.Year).isoWeek(d.Week).startOf('isoWeek').format('MMM D, YYYY');
                    const value = d[csvHeader];
                    const alertLevel = d[selectedMetric + 'Alert'] || 'normal';
                    const color = getAlertColor(alertLevel);
                    const displayValue = (value !== null && value !== undefined) ? (metricDef?.type === 'percentage' ? `${value}%` : value) : 'N/A';
                    const tooltip = `<div style="padding:10px;"><b>${weekLabel}</b><br>${metricName}: <b>${displayValue}</b><br>Alert: ${alertLevel.toUpperCase()}</div>`;
                    // Add row only if value is a number
                    if (typeof value === 'number') {
                        trendData.addRow([weekLabel, value, tooltip, `point { fill-color: ${color}; }`]);
                    } else {
                        // Handle null/missing values - add null to keep timeline, but no point/tooltip
                        trendData.addRow([weekLabel, null, null, null]); 
                    }
                });
    
                const trendOptions = {
                    title: `${metricName} Trend for ${selectedClinic === 'all' ? 'All Clinics (Avg)' : selectedClinic}`,
                    curveType: 'function',
                    legend: { position: 'bottom' },
                    hAxis: { title: 'Week Start', slantedText: true, slantedTextAngle: 45 },
                    vAxis: { title: metricDef?.type === 'percentage' ? 'Value (%)' : 'Value' },
                    tooltip: { isHtml: true },
                    pointSize: 5,
                    connectSteps: false // Don't connect gaps for null values
                };
    
                // Use try/catch for chart drawing
                try {
                     if (!trendChart) {
                        trendChart = new google.visualization.LineChart(document.getElementById('trendChart'));
                     }
                     trendChart.draw(trendData, trendOptions);
                } catch (e) {
                     console.error("Error drawing trend chart:", e);
                     document.getElementById('trendChart').innerHTML = '<p style="color:red;">Error drawing trend chart.</p>';
                }
    
                // Prepare data for Comparison Chart (Snapshot of last week in range)
                const lastWeekData = filteredData[filteredData.length - 1];
                if (selectedClinic !== 'all' && lastWeekData) {
                     const comparisonData = new google.visualization.DataTable();
                     comparisonData.addColumn('string', 'Metric');
                     comparisonData.addColumn('number', 'Value');
                     comparisonData.addColumn({type: 'string', role: 'style'});
                     comparisonData.addColumn({type: 'string', role: 'tooltip'});
    
                     metricsDefinition.forEach(metric => {
                         // if (metric.type !== 'text') { // Already filtered
                             const mCsvHeader = metric.id.charAt(0).toUpperCase() + metric.id.slice(1);
                             const value = lastWeekData[mCsvHeader];
                             const alertLevel = lastWeekData[metric.id + 'Alert'] || 'normal';
                             
                             // Get dynamic benchmark for tooltip
                             const weekKey = `${lastWeekData.Year}-W${lastWeekData.Week}`;
                             const weeklyBenchmarks = benchmarkData[weekKey];
                             const target = weeklyBenchmarks ? weeklyBenchmarks[mCsvHeader] : null;
                             let targetText = '';
                             if (target !== null && target !== undefined) {
                                 targetText = metric.type === 'percentage' ? `Target: ${target}%` : `Target: ${target}`;
                             } else {
                                 targetText = 'Target: N/A';
                             }
                             
                             const tooltip = `${metric.name}: ${metric.type === 'percentage' ? value+'%' : value} (${alertLevel.toUpperCase()})\n${targetText}`;
                             // Add row only if value is a number
                             if (typeof value === 'number') {
                                 comparisonData.addRow([metric.name, value, getAlertColor(alertLevel), tooltip]);
                             }
                         // }
                     });
                     
                     const comparisonOptions = {
                        title: `Metric Snapshot for ${selectedClinic} (Week ${lastWeekData.Week}, ${lastWeekData.Year})`,
                        legend: { position: 'none' },
                        bars: 'horizontal', 
                        hAxis: { title: 'Value' },
                        vAxis: { title: 'Metric' },
                        tooltip: { trigger: 'focus' } // Show tooltip on hover/focus
                     };
                     
                     try {
                         if (!comparisonChart) {
                             comparisonChart = new google.visualization.BarChart(document.getElementById('comparisonChart'));
                         }
                         comparisonChart.draw(comparisonData, comparisonOptions);
                     } catch (e) {
                         console.error("Error drawing comparison chart:", e);
                         document.getElementById('comparisonChart').innerHTML = '<p style="color:red;">Error drawing comparison chart.</p>';
                     }
    
                } else {
                     document.getElementById('comparisonChart').innerHTML = '<p>Select a specific clinic to see a snapshot comparison.</p>';
                }
    
                hideLoading();
            }
            
            // Helper function to average historical data across all clinics for each week
            function averageHistoricalData() {
                const averagedData = [];
                availableWeeks.forEach(weekInfo => {
                    const clinicsForWeek = Object.values(allClinicsData)
                                               .map(clinicHistory => clinicHistory.find(d => d.Year === weekInfo.year && d.Week === weekInfo.week))
                                               .filter(Boolean); // Filter out clinics with no data for that week
                    if (clinicsForWeek.length > 0) {
                        const avgWeekData = averageClinicData(clinicsForWeek, weekInfo.year, weekInfo.week); // Pass week info for benchmark lookup
                        avgWeekData.Year = weekInfo.year;
                        avgWeekData.Week = weekInfo.week;
                        averagedData.push(avgWeekData);
                    }
                });
                return averagedData;
            }
    
            // Handle selection of metric in historical tab
            function selectMetric(metricId) {
                selectedMetric = metricId;
                // Update active button style
                document.querySelectorAll('#metricSelector button').forEach(button => {
                    button.classList.toggle('active', button.dataset.metric === metricId);
                });
                updateHistoricalCharts();
                // Update detail chart if panel is open
                if (document.getElementById('detailsPanel').classList.contains('open')) {
                     const clinicName = document.getElementById('detailsTitle').textContent.split(' - ')[0];
                     if (clinicName && clinicName !== 'Clinic Details') {
                         drawDetailTrendChart(clinicName);
                         const metricDef = metricsDefinition.find(m=>m.id===metricId);
                         const metricName = metricDef?.name || metricId;
                         const headerEl = document.getElementById('detailTrendHeader');
                         if(headerEl) headerEl.textContent = `Historical Trend (${metricName}):`;
                     }
                }
            }
    
            // Handle selection of clinic in historical tab
            document.getElementById('clinicSelector').addEventListener('change', function() {
                selectedClinic = this.value;
                updateHistoricalCharts();
            });
    
            // Draw simple trend chart in details panel
            function drawDetailTrendChart(clinicName) {
                 if (!google.visualization || !google.visualization.DataTable) return;
                 const detailChartDiv = document.getElementById('detailTrendChart');
                 if (!detailChartDiv) return;
                 
                 const clinicHistory = allClinicsData[clinicName];
                 if (!clinicHistory) {
                     detailChartDiv.innerHTML = '<p>Historical data not found.</p>';
                     // return;
                 }
    
                 const filteredData = clinicHistory.filter(d => {
                    const weekMoment = moment().year(d.Year).isoWeek(d.Week);
                    return weekMoment.isBetween(dateRange.start, dateRange.end, 'day', '[]');
                }).sort((a, b) => {
                     if (a.Year !== b.Year) return a.Year - b.Year;
                     return a.Week - b.Week;
                });
    
                 if (filteredData.length === 0) {
                     detailChartDiv.innerHTML = '<p>No data in selected range.</p>';
                     // return;
                 }
    
                 const detailData = new google.visualization.DataTable();
                 detailData.addColumn('string', 'Week');
                 const metricDef = metricsDefinition.find(m => m.id === selectedMetric);
                 const metricName = metricDef?.name || selectedMetric;
                 const csvHeader = selectedMetric.charAt(0).toUpperCase() + selectedMetric.slice(1);
                 detailData.addColumn('number', metricName);
                 detailData.addColumn({type: 'string', role: 'style'});
    
                 filteredData.forEach(d => {
                    const weekLabel = moment().year(d.Year).isoWeek(d.Week).startOf('isoWeek').format('MMM D, YYYY');
                    const value = d[csvHeader];
                    const alertLevel = d[selectedMetric + 'Alert'] || 'normal';
                    if (typeof value === 'number') {
                        detailData.addRow([weekLabel, value, `point { fill-color: ${getAlertColor(alertLevel)}; }`]);
                    } else {
                        detailData.addRow([weekLabel, null, null]);
                    }
                });
    
                 const detailOptions = {
                    title: `${metricName} Trend for ${clinicName}`,
                    legend: { position: 'none' },
                    hAxis: { textPosition: 'none' }, // Simpler axis for small chart
                    vAxis: { textPosition: 'none' },
                    chartArea: {width: '85%', height: '70%'},
                    pointSize: 3,
                    connectSteps: false
                };
                
                try {
                     const detailChart = new google.visualization.LineChart(detailChartDiv);
                     detailChart.draw(detailData, detailOptions);
                } catch (e) {
                     console.error("Error drawing detail chart:", e);
                     detailChartDiv.innerHTML = '<p style="color:red;">Error drawing chart.</p>';
                }
            }
    
            // --- Comparison Tab Functions ---
    
            // Switch between comparison types (Week-to-Week, 4 Weeks, Custom Ranges)
            function switchComparisonType(event, type) {
                // Update button styles
                document.querySelectorAll('.comparison-type-selector button').forEach(button => {
                    button.classList.remove('active');
                });
                event.currentTarget.classList.add('active');
    
                // Show/hide relevant options sections
                document.querySelectorAll('.comparison-options').forEach(section => {
                    section.classList.remove('active');
                });
                // Construct ID dynamically: comparisonOptions + CapitalizedType (removing hyphens)
                const optionsId = 'comparisonOptions' + type.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('');
                document.getElementById(optionsId).classList.add('active');
                
                // Clear previous results
                document.getElementById('comparisonResults').innerHTML = '';
            }
    
            // Run the selected comparison
            function runComparison(type) {
                if (Object.keys(allClinicsData).length === 0) {
                     alert("Please load data first.");
                     // return;
                }
                showLoading("Running comparison...");
                console.log(`Running comparison type: ${type}`);
                let comparisonHTML = `<h4>Comparison Results (${type})</h4>`;
                let clinicName, data1, data2, week1Info, week2Info, week3Info, week4Info;
    
                try {
                    switch (type) {
                        case 'week-to-week':
                            clinicName = document.getElementById('compareClinicSelectorW2W').value;
                            week2Info = availableWeeks[availableWeeks.length - 1]; // Current week
                            week1Info = availableWeeks[availableWeeks.length - 2]; // Previous week
                            
                            if (!week1Info || !week2Info) throw new Error("Not enough historical data (need at least 2 weeks).");
    
                            data1 = getWeekData(clinicName, week1Info.year, week1Info.week);
                            data2 = getWeekData(clinicName, week2Info.year, week2Info.week);
                            
                            const date1Str = moment().year(week1Info.year).isoWeek(week1Info.week).startOf('isoWeek').format('MMM D, YYYY');
                            const date2Str = moment().year(week2Info.year).isoWeek(week2Info.week).startOf('isoWeek').format('MMM D, YYYY');
                            comparisonHTML += `<p>Comparing ${date1Str} vs ${date2Str} for ${clinicName === 'all' ? 'All Clinics (Avg)' : clinicName}</p>`;
                            comparisonHTML += generateComparisonTable(data1, data2, date1Str, date2Str, clinicName === 'all');
                            break;
    
                        case '4-weeks':
                            clinicName = document.getElementById('compareClinicSelector4W').value;
                            const week1Str = document.getElementById('compareWeek1').value;
                            const week2Str = document.getElementById('compareWeek2').value;
                            const week3Str = document.getElementById('compareWeek3').value;
                            const week4Str = document.getElementById('compareWeek4').value;
                            
                            const weeksInfo = [week1Str, week2Str, week3Str, week4Str].map(parseWeekString);
                            // Ensure 4-week comparison goes from oldest to newest
    weeksInfo.sort((a, b) => {
        if (a.year !== b.year) return a.year - b.year;
        return a.week - b.week;
    });
                            const weekData = weeksInfo.map(w => getWeekData(clinicName, w.year, w.week));
                            const weekLabels = weeksInfo.map(w => moment().year(w.year).isoWeek(w.week).startOf('isoWeek').format('MMM D, YYYY'));
    
                            comparisonHTML += `<p>Comparing Weeks: ${weekLabels.join(', ')} for ${clinicName === 'all' ? 'All Clinics (Avg)' : clinicName}</p>`;
                            comparisonHTML += generateMultiComparisonTable(weekData, weekLabels, clinicName === 'all');
                            break;
    
                        case 'custom-ranges':
                             clinicName = document.getElementById('compareClinicSelectorCR').value;
                             const range1Picker = $('#compareRangePicker1').data('daterangepicker');
                             const range2Picker = $('#compareRangePicker2').data('daterangepicker');
                             
                             if (!range1Picker || !range2Picker) throw new Error("Date range pickers not initialized.");
                             
                             const dataRange1 = getRangeData(clinicName, range1Picker.startDate, range1Picker.endDate);
                             const dataRange2 = getRangeData(clinicName, range2Picker.startDate, range2Picker.endDate);
    
                             const label1 = `${range1Picker.startDate.format('MMM D')} - ${range1Picker.endDate.format('MMM D, YYYY')}`;
                             const label2 = `${range2Picker.startDate.format('MMM D')} - ${range2Picker.endDate.format('MMM D, YYYY')}`;
    
                             comparisonHTML += `<p>Comparing Range: ${label1} vs ${label2} for ${clinicName === 'all' ? 'All Clinics (Avg)' : clinicName}</p>`;
                             comparisonHTML += generateComparisonTable(dataRange1, dataRange2, label1, label2, true); // Indicate ranges are averaged
                            break;
    
                        default:
                            comparisonHTML += '<p>Invalid comparison type selected.</p>';
                    }
                } catch (error) {
                    console.error("Comparison Error:", error);
                    comparisonHTML += `<p style="color: red;">Error running comparison: ${error.message}</p>`;
                }
    
                document.getElementById('comparisonResults').innerHTML = comparisonHTML;
                hideLoading();
            }
    
            // Helper to parse 'YYYY-Www' string
            function parseWeekString(weekStr) {
                const parts = weekStr.split('-W');
                if (parts.length !== 2) return { year: NaN, week: NaN };
                return { year: parseInt(parts[0]), week: parseInt(parts[1]) };
            }
    
            // Helper to get data for a specific week (or average for 'all')
            function getWeekData(clinicName, year, week) {
                if (clinicName === 'all') {
                    // Calculate average across all clinics for that week
                    const clinicsForWeek = Object.values(allClinicsData)
                                               .map(clinicHistory => clinicHistory.find(d => d.Year === year && d.Week === week))
                                               .filter(Boolean); // Filter out clinics with no data for that week
                    if (clinicsForWeek.length === 0) return null; // No data for any clinic this week
                    return averageClinicData(clinicsForWeek, year, week); // Pass week info
                } else {
                    const clinicHistory = allClinicsData[clinicName];
                    return clinicHistory ? clinicHistory.find(d => d.Year === year && d.Week === week) : null;
                }
            }
            
            // Helper to get aggregated/averaged data for a date range
            function getRangeData(clinicName, startDate, endDate) {
                 let dataInRange;
                 let weeksInRange = new Set(); // Track unique weeks in range
                 
                 if (clinicName === 'all') {
                     // Get data for all clinics within the range
                     dataInRange = Object.values(allClinicsData).flat().filter(d => {
                         const weekMoment = moment().year(d.Year).isoWeek(d.Week);
                         const isInRange = weekMoment.isBetween(startDate, endDate, 'day', '[]');
                         if (isInRange) weeksInRange.add(`${d.Year}-W${d.Week}`);
                         return isInRange;
                     });
                 } else {
                     const clinicHistory = allClinicsData[clinicName];
                     if (!clinicHistory) return null;
                     dataInRange = clinicHistory.filter(d => {
                         const weekMoment = moment().year(d.Year).isoWeek(d.Week);
                         const isInRange = weekMoment.isBetween(startDate, endDate, 'day', '[]');
                         if (isInRange) weeksInRange.add(`${d.Year}-W${d.Week}`);
                         return isInRange;
                     });
                 }
                 
                 if (!dataInRange || dataInRange.length === 0) return null;
                 
                 // Average the data points within the range
                 // Pass the set of weeks to averageClinicData to look up relevant benchmarks
                 return averageClinicData(dataInRange, null, null, Array.from(weeksInRange));
            }
    
            // Helper function to average data from multiple clinic data objects
            // Can average for a specific week OR a range of weeks
            function averageClinicData(dataArray, specificYear = null, specificWeek = null, weekKeysInRange = null) {
                if (!dataArray || dataArray.length === 0) return null;
                const avgData = { Clinic: 'Average' }; 
                avgData.Year = specificYear !== null ? specificYear : 'Range';
                avgData.Week = specificWeek !== null ? specificWeek : 'Range';
                const counts = {};
                const alertCounts = { critical: 0, high: 0, low: 0, normal: 0 };
    
                // Initialize sums and counts
                metricsDefinition.forEach(metric => {
                    const csvHeader = metric.id.charAt(0).toUpperCase() + metric.id.slice(1);
                    avgData[csvHeader] = 0;
                    counts[csvHeader] = 0;
                });
                // Also handle notes alert averaging (e.g., count occurrences)
                avgData['AreaManagerNotesAlert'] = { critical: 0, high: 0, low: 0, normal: 0 };
    
                // Sum values and count valid entries
                dataArray.forEach(clinic => {
                    metricsDefinition.forEach(metric => {
                        const csvHeader = metric.id.charAt(0).toUpperCase() + metric.id.slice(1);
                        const value = clinic[csvHeader];
                        if (value !== null && value !== undefined && typeof value === 'number') {
                            avgData[csvHeader] += value;
                            counts[csvHeader]++;
                        }
                    });
                    // Count notes alerts
                    const notesAlert = clinic['areaManagerNotesAlertLevel'] || 'normal';
                    avgData['AreaManagerNotesAlert'][notesAlert]++;
                });
    
                // Calculate averages and determine average alert levels
                metricsDefinition.forEach(metric => {
                     const csvHeader = metric.id.charAt(0).toUpperCase() + metric.id.slice(1);
                     const avgValue = counts[csvHeader] > 0 ? parseFloat((avgData[csvHeader] / counts[csvHeader]).toFixed(1)) : null;
                     avgData[csvHeader] = avgValue;
                     
                     // Determine alert for the average value
                     if (avgValue !== null) {
                         // Need benchmark for the specific week/range
                         let target = null;
                         let higherIsBetter = true; // Default
                         let benchmarkSourceWeekKey = null;
                         
                         if (specificYear !== null && specificWeek !== null) {
                             benchmarkSourceWeekKey = `${specificYear}-W${specificWeek}`;
                         } else if (weekKeysInRange && weekKeysInRange.length > 0) {
                             // For ranges, maybe use the benchmark from the *last* week in the range?
                             // Or average benchmarks? For simplicity, use last week's benchmark.
                             const sortedWeeks = weekKeysInRange.sort((a, b) => {
                                  const [yA, wA] = a.split('-W').map(Number);
                                  const [yB, wB] = b.split('-W').map(Number);
                                  if (yA !== yB) return yA - yB;
                                  return wA - wB;
                             });
                             benchmarkSourceWeekKey = sortedWeeks[sortedWeeks.length - 1];
                         }
                         
                         const weeklyBenchmarks = benchmarkSourceWeekKey ? benchmarkData[benchmarkSourceWeekKey] : null;
                         if (weeklyBenchmarks) {
                             target = weeklyBenchmarks[csvHeader];
                             const flag = weeklyBenchmarks[csvHeader + '_HigherIsBetter'];
                             higherIsBetter = (flag === null || flag === undefined) ? true : flag;
                         }
                         
                         avgData[metric.id + 'Alert'] = getAlertLevel(avgValue, target, higherIsBetter, metric.id);
                     } else {
                         avgData[metric.id + 'Alert'] = 'normal';
                     }
                     alertCounts[avgData[metric.id + 'Alert']]++; // Count alerts based on average
                });
                
                // Determine overall alert for the average
                if (alertCounts.critical > 0) avgData.overallAlert = 'critical';
                else if (alertCounts.high > 0) avgData.overallAlert = 'high';
                else if (alertCounts.low > 0) avgData.overallAlert = 'low';
                else avgData.overallAlert = 'normal';
                
                // Determine the most frequent notes alert level for the average
                let maxCount = 0;
                let dominantNotesAlert = 'normal';
                for (const level in avgData['AreaManagerNotesAlert']) {
                     if (avgData['AreaManagerNotesAlert'][level] > maxCount) {
                         maxCount = avgData['AreaManagerNotesAlert'][level];
                         dominantNotesAlert = level;
                     }
                }
                avgData['areaManagerNotesAlertLevel'] = dominantNotesAlert;
                delete avgData['AreaManagerNotesAlert']; // Remove the count object
    
                // Note: Trends are not averaged meaningfully here.
                avgData.weeklyTrend = 'N/A'; 
                return avgData;
            }
    
            // Generate HTML table for comparing two data points/ranges
            function generateComparisonTable(data1, data2, label1, label2, isAverage = false) {
                let tableHTML = `<table class="comparison-table">
                                    <thead>
                                        <tr><th>Metric</th><th>${label1} ${isAverage ? '(Avg)' : ''}</th><th>${label2} ${isAverage ? '(Avg)' : ''}</th><th>Change</th></tr>
                                    </thead>
                                    <tbody>`;
    
                if (!data1 || !data2) {
                    return '<p>Comparison data is missing for one or both periods.</p>';
                }
    
                // Handle Notes Alert separately
                const notesAlert1 = data1['areaManagerNotesAlertLevel'] || 'N/A';
                const notesAlert2 = data2['areaManagerNotesAlertLevel'] || 'N/A';
                tableHTML += `<tr>
                                <td class="metric-name">Notes Alert</td>
                                <td><span class="alert-badge alert-${notesAlert1}">${notesAlert1.toUpperCase()}</span></td>
                                <td><span class="alert-badge alert-${notesAlert2}">${notesAlert2.toUpperCase()}</span></td>
                                <td>${notesAlert1 === notesAlert2 ? 'Same' : 'Changed'}</td>
                              </tr>`;
    
                metricsDefinition.forEach(metric => {
                    // if (metric.type === 'text') return; // Already filtered
    
                    const csvHeader = metric.id.charAt(0).toUpperCase() + metric.id.slice(1);
                    const val1 = data1[csvHeader];
                    const val2 = data2[csvHeader];
                    let displayVal1 = 'N/A';
                    let displayVal2 = 'N/A';
                    let change = 'N/A';
                    let changeClass = '';
                    
                    // Need higherIsBetter flag (use benchmark from second period for consistency)
                    let higherIsBetter = true; // Default
                    const weekKey2 = `${data2.Year}-W${data2.Week}`;
                    const benchmark2 = data2.Year !== 'Range' ? benchmarkData[weekKey2] : null; // Get benchmark for period 2 if not a range
                    if (benchmark2) {
                         const flag = benchmark2[csvHeader + '_HigherIsBetter'];
                         higherIsBetter = (flag === null || flag === undefined) ? true : flag;
                    }
    
                    if (val1 !== null && val1 !== undefined) displayVal1 = metric.type === 'percentage' ? `${val1}%` : val1;
                    if (val2 !== null && val2 !== undefined) displayVal2 = metric.type === 'percentage' ? `${val2}%` : val2;
    
                    if (typeof val1 === 'number' && typeof val2 === 'number') {
                        const diff = val2 - val1;
                        change = `${diff >= 0 ? '+' : ''}${diff.toFixed(1)}${metric.type === 'percentage' ? '%' : ''}`;
                        if (Math.abs(diff) > 0.01) { // Add a small threshold to avoid marking tiny changes
                        // Use metric.higherIsBetter if present, otherwise fall back to benchmark or default
                      let metricHigherIsBetter = typeof metric.higherIsBetter === 'boolean' ? metric.higherIsBetter : higherIsBetter;
                     if (diff > 0) changeClass = metricHigherIsBetter ? 'change-positive' : 'change-negative';
                    if (diff < 0) changeClass = metricHigherIsBetter ? 'change-negative' : 'change-positive';
    }
                    }
    
                    tableHTML += `<tr>
                                    <td class="metric-name">${metric.name}</td>
                                    <td>${displayVal1}</td>
                                    <td>${displayVal2}</td>
                                    <td class="${changeClass}">${change}</td>
                                  </tr>`;
                });
    
                tableHTML += `</tbody></table>`;
                return tableHTML;
            }
            
            // Generate HTML table for comparing multiple data points (e.g., 4 weeks)
            function generateMultiComparisonTable(dataArray, labels, isAverage = false) {
                 let tableHTML = `<table class="comparison-table">
                                    <thead>
                                        <tr><th>Metric</th>`;
                 labels.forEach(label => tableHTML += `<th>${label} ${isAverage ? '(Avg)' : ''}</th>`);
                 tableHTML += `<th>Trend</th></tr></thead><tbody>`;
    
                 if (dataArray.some(d => !d)) {
                     return '<p>Comparison data is missing for one or more periods.</p>';
                 }
                 
                 // Handle Notes Alert separately
                 tableHTML += `<tr><td class="metric-name">Notes Alert</td>`;
                 let notesAlerts = [];
                 dataArray.forEach(data => {
                     const notesAlert = data['areaManagerNotesAlertLevel'] || 'N/A';
                     tableHTML += `<td><span class="alert-badge alert-${notesAlert}">${notesAlert.toUpperCase()}</span></td>`;
                     notesAlerts.push(notesAlert);
                 });
                 // Basic trend for notes (first vs last)
                 let notesTrend = 'N/A';
                 if (notesAlerts.length >= 2) {
                     notesTrend = notesAlerts[0] === notesAlerts[notesAlerts.length - 1] ? 'Stable' : 'Changed';
                 }
                 tableHTML += `<td>${notesTrend}</td></tr>`;
    
                 metricsDefinition.forEach(metric => {
                     // if (metric.type === 'text') return;
    
                     tableHTML += `<tr><td class="metric-name">${metric.name}</td>`;
                     let values = [];
                     // Always prefer the flag from metricsDefinition
    let higherIsBetter = true;
    if (typeof metric.higherIsBetter === 'boolean') {
        higherIsBetter = metric.higherIsBetter;
    } else {
        // fallback to benchmark flag if not set in metricsDefinition
        const lastData = dataArray[dataArray.length - 1];
        const lastWeekKey = `${lastData.Year}-W${lastData.Week}`;
        const lastBenchmark = lastData.Year !== 'Range' ? benchmarkData[lastWeekKey] : null;
        if (lastBenchmark) {
            const csvHeader = metric.id.charAt(0).toUpperCase() + metric.id.slice(1);
            const flag = lastBenchmark[csvHeader + '_HigherIsBetter'];
            higherIsBetter = (flag === null || flag === undefined) ? true : flag;
        }
    }
                     
                     dataArray.forEach(data => {
                         const csvHeader = metric.id.charAt(0).toUpperCase() + metric.id.slice(1);
                         const val = data[csvHeader];
                         let displayVal = 'N/A';
                         if (val !== null && val !== undefined) displayVal = metric.type === 'percentage' ? `${val}%` : val;
                         tableHTML += `<td>${displayVal}</td>`;
                         if (typeof val === 'number') values.push(val);
                     });
                     
                     // Use higherIsBetter from metricsDefinition ONLY
    let trend = 'N/A';
    let trendClass = '';
    if (values.length >= 2) {
        const diff = values[values.length - 1] - values[0];
        console.log(metric.id, "higherIsBetter:", metric.higherIsBetter, "diff:", diff);
        // Use metric.higherIsBetter, default to true if undefined
        const metricHigherIsBetter = typeof metric.higherIsBetter === 'boolean' ? metric.higherIsBetter : true;
        if (diff > 0.1) {
            trend = metricHigherIsBetter ? 'Improving' : 'Worsening';
            trendClass = metricHigherIsBetter ? 'change-positive' : 'change-negative';
        } else if (diff < -0.1) {
            trend = metricHigherIsBetter ? 'Worsening' : 'Improving';
            trendClass = metricHigherIsBetter ? 'change-negative' : 'change-positive';
        } else {
            trend = 'Stable';
        }
    }
                     tableHTML += `<td class="${trendClass}">${trend}</td>`;
                     tableHTML += `</tr>`;
                 });
    
                 tableHTML += `</tbody></table>`;
                 return tableHTML;
            }
    
            // --- Utility Functions ---
// Generate HTML for a metric cell with alert badge, trend arrow, and target deviation.
function generateMetricCell(entry, metricId){
    const csvHeader = metricId.charAt(0).toUpperCase()+metricId.slice(1);
    const rawVal   = entry[csvHeader];
    const target   = entry[csvHeader+'Target']; // may be pre-computed in dataset
    const trend    = entry[metricId+'Trend'];   // expected values: 'up','down','same'
    const alertLevel = entry[metricId+'Alert']||'normal';
    const metricMeta = metricsDefinition.find(m=>m.id===metricId) || {type:'number'};

    let display = 'N/A';
    if(rawVal!==null && rawVal!==undefined && rawVal!==''){
        if(metricMeta.type==='percentage'){
            const num=parseFloat(rawVal);
            display = isNaN(num)? rawVal : num.toFixed(1)+'%';
        } else {
            display = rawVal;
        }
    }
    const arrow = getTrendArrow(trend);
    let arrowSpan='';
    if(arrow){
        arrowSpan=`<span class="trend-arrow trend-${trend||'same'}">${arrow}</span>`;
    }
    // Determine target: prefer benchmarkData for entry's week, fallback to in-row target column
    const benchKey = (typeof benchmarkData!=='undefined') ? `${entry.Year}-W${entry.Week}` : null;
    let benchTarget;
    if(benchKey && benchmarkData[benchKey]){
        benchTarget = benchmarkData[benchKey][csvHeader];
    }
    const targetVal = (benchTarget!==undefined && benchTarget!==null && benchTarget!=='') ? benchTarget : target;

    let targetText='Target: N/A';
    if(targetVal!==undefined && targetVal!==null && targetVal!==''){
        let tDisplay = targetVal;
        if(metricMeta.type==='percentage'){
            const n=parseFloat(targetVal);
            tDisplay = isNaN(n)? targetVal : n.toFixed(1)+'%';
        }
        targetText = `Target: ${tDisplay}`;
    }

    return `<td class="metric-value">
                <div>${display} ${arrowSpan}</div>
                <span class="alert-badge alert-${alertLevel}">${alertLevel.toUpperCase()}</span>
                <div class="deviation">${targetText}</div>
            </td>`;
}

// Generate cell for daily pivot table (if needed)
function generateDailyMetricCell(row, metricId){
    const metricMap = { targetVisits:'Target of Visits', googleReviews:'Google Reviews', newPatients:'New Patients Target', noUpcoming:'No Upcoming %', cancellation:'Cancellation %', noShow:'No Show %', utilization:'Utilization %', satisfactionCollect:'Satisfaction Collection %' };
    const header = metricMap[metricId] || metricId;
    const val = row[header];
    const display = (val===null||val===undefined||val==='') ? 'N/A' : val;
    const alert = row[metricId+'Alert']||'normal';
    return `<td class="metric-value"><span class="alert-badge alert-${alert}">${display}</span></td>`;
}
    
            // Show loading overlay
            function showLoading(message = "Loading...") {
                document.getElementById('loadingMessage').textContent = message;
                document.getElementById('loadingOverlay').style.display = 'flex';
            }
    
            // Hide loading overlay
            function hideLoading(message = null) {
                 const overlay = document.getElementById('loadingOverlay');
                 const msgElement = document.getElementById('loadingMessage');
                 const spinner = overlay.querySelector('.spinner');
                 
                 if (message) {
                     // Show message instead of hiding immediately
                     msgElement.textContent = message;
                     if (spinner) spinner.style.display = 'none';
                     // Keep overlay visible briefly or until interaction if needed
                     // setTimeout(() => { overlay.style.display = 'none'; }, 3000); // Example: hide after 3s
                 } else {
                     overlay.style.display = 'none';
                     if (spinner) spinner.style.display = 'block'; // Ensure spinner is visible next time
                 }
            }
    
            // Export currently filtered data to CSV
            function exportData() {
                console.log("Exporting data...");
                if (!displayedData || displayedData.length === 0) {
                    alert("No data to export based on current filters.");
                    // return;
                }
                showLoading("Preparing CSV export...");
    
                // Use the updated expected headers for the DATA sheet
                const headers = expectedDataCsvHeaders;
                let csvContent = "data:text/csv;charset=utf-8," + headers.join(",") + "\n";
    
                displayedData.forEach(clinic => {
                    let row = headers.map(header => {
                        let value = clinic[header]; // Access data using the exact header string
                        if (value === null || value === undefined) {
                            return ''; // Represent null/undefined as empty string in CSV
                        }
                        // Enclose in quotes if value contains comma, quote, or newline; escape quotes
                        value = String(value);
                        if (value.includes(',') || value.includes('"') || value.includes('\n')) {
                            return `"${value.replace(/"/g, '""')}"`;
                        }
                        return value;
                    });
                    csvContent += row.join(",") + "\n";
                });
    
                // Create a link and trigger download
                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                const timePeriod = document.getElementById('timePeriodFilter').value;
                const weekInfo = (timePeriod === 'current' && latestWeek.year > 0) ? latestWeek : previousWeek;
                link.setAttribute("download", `clinic_metrics_export_W${weekInfo.week}_${weekInfo.year}.csv`);
                document.body.appendChild(link); // Required for Firefox
                link.click();
       
    function showTab(tabId) {
        // Hide all tabs
        const tabs = document.querySelectorAll('.tab-content');
        tabs.forEach(tab => tab.style.display = 'none');
        
        // Show the selected tab
        document.getElementById(tabId).style.display = 'block';
        
        // Update active tab button
        const tabButtons = document.querySelectorAll('.tab-button');
        tabButtons.forEach(button => button.classList.remove('active'));
        
        // Find and activate the clicked button
        tabButtons.forEach(button => {
            if (button.getAttribute('onclick').includes(tabId)) {
                button.classList.add('active');
            }
        });
    }
    
    // Meeting Notes Google Sheet URL
    const meetingNotesSheetUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQeN0UumxiDN3Qp5H8J0bKZOvkMgRBvNe-G8KYja32gNGE_Rws90BGR4EShDrpXoqWiuZpnfaKmrAzN/pub?gid=1857583669&single=true&output=csv';
             document.body.removeChild(link);
                hideLoading();
                console.log("Export complete.");
            }
    
        
    // Meeting Notes Functionality
    let meetingNotesData = [];
    
    async function fetchMeetingNotesData() {
        try {
            // Replace with your actual Google Sheet URL
            const response = await fetch(meetingNotesSheetUrl);
            if (!response.ok) {
                throw new Error('Failed to fetch meeting notes data');
            }
            
            const csvText = await response.text();
            return parseMeetingNotesCSV(csvText);
        } catch (error) {
            console.error("Error fetching meeting notes data:", error);
            return [];
        }
    }
    
    function parseMeetingNotesCSV(csvText) {
        // Simple CSV parsing
        const lines = csvText.trim().split('\n');
        const headers = lines[0].split(',');
        
        return lines.slice(1).map(line => {
            const values = line.split(',');
            const entry = {};
            
            headers.forEach((header, index) => {
                entry[header.trim()] = values[index]?.trim() || '';
            });
            
            return entry;
        });
    }
    
    function populateMeetingNotesFilters() {
        // Populate clinic filter
        const clinicSelect = document.getElementById('meetingClinicFilter');
        const clinics = [...new Set(meetingNotesData.map(note => note.Clinic))];
        
        clinicSelect.innerHTML = '<option value="all">All Clinics</option>';
        clinics.forEach(clinic => {
            if (clinic) {
                const option = document.createElement('option');
                option.value = clinic;
                option.textContent = clinic;
                clinicSelect.appendChild(option);
            }
        });
        
        // Populate metric filter
        const metricSelect = document.getElementById('meetingMetricFilter');
        const metrics = [...new Set(meetingNotesData.map(note => note.Metric))];
        
        metricSelect.innerHTML = '<option value="all">All Metrics</option>';
        metrics.forEach(metric => {
            if (metric) {
                const option = document.createElement('option');
                option.value = metric;
                option.textContent = metric;
                metricSelect.appendChild(option);
            }
        });
        
        // Initialize date picker
        $('#meetingDateFilter').daterangepicker({
            startDate: moment().subtract(30, 'days'),
            endDate: moment(),
            opens: 'left',
            ranges: {
               'Last 30 Days': [moment().subtract(29, 'days'), moment()],
               'This Month': [moment().startOf('month'), moment().endOf('month')],
               'Last Month': [moment().subtract(1, 'month').startOf('month'), moment().subtract(1, 'month').endOf('month')],
               'Last 3 Months': [moment().subtract(3, 'month'), moment()]
            }
        });
    }
    
    function displayMeetingNotes() {
        const container = document.getElementById('meetingNotesContainer');
        container.innerHTML = '';
        
        // Get filter values
        const dateRange = $('#meetingDateFilter').data('daterangepicker');
        const startDate = dateRange.startDate.format('YYYY-MM-DD');
        const endDate = dateRange.endDate.format('YYYY-MM-DD');
        
        const clinicFilter = document.getElementById('meetingClinicFilter').value;
        const metricFilter = document.getElementById('meetingMetricFilter').value;
        const statusFilter = document.getElementById('meetingStatusFilter').value;
        
        // Filter the data
        const filteredData = meetingNotesData.filter(note => {
            const meetingDate = note['Date of meeting'];
            const isDone = note.Done === 'TRUE' || note.Done === true || note.Done === '✓';
            
            // Date filter
            const isInDateRange = moment(meetingDate).isBetween(startDate, endDate, null, '[]');
            
            // Clinic filter
            const matchesClinic = clinicFilter === 'all' || note.Clinic === clinicFilter;
            
            // Metric filter
            const matchesMetric = metricFilter === 'all' || note.Metric === metricFilter;
            
            // Status filter
            const matchesStatus = statusFilter === 'all' || 
                                  (statusFilter === 'done' && isDone) || 
                                  (statusFilter === 'not-done' && !isDone);
            
            return isInDateRange && matchesClinic && matchesMetric && matchesStatus;
        });
        
        // Group by meeting date
        const meetingsByDate = {};
        filteredData.forEach(note => {
            if (!meetingsByDate[note['Date of meeting']]) {
                meetingsByDate[note['Date of meeting']] = [];
            }
            meetingsByDate[note['Date of meeting']].push(note);
        });
        
        // Sort dates in reverse chronological order
        const sortedDates = Object.keys(meetingsByDate).sort((a, b) => {
            return moment(b, 'MM-DD-YYYY').valueOf() - moment(a, 'MM-DD-YYYY').valueOf();
        });
        
        if (sortedDates.length === 0) {
            container.innerHTML = '<p>No meeting notes found matching the filters.</p>';
            return;
        }
        
        // Create a box for each meeting date
        sortedDates.forEach(date => {
            const formattedDate = moment(date, 'MM-DD-YYYY').format('MM-DD-YYYY');
            const meetingBox = document.createElement('div');
            meetingBox.className = 'meeting-box';
            
            const meetingHeader = document.createElement('h3');
            meetingHeader.textContent = 'Date of meeting: ' + formattedDate;
            meetingBox.appendChild(meetingHeader);
            
            const checklist = document.createElement('ul');
            checklist.className = 'meeting-checklist';
            
            meetingsByDate[date].forEach(item => {
                const listItem = document.createElement('li');
                const isDone = item.Done === 'TRUE' || item.Done === true || item.Done === '✓';
                
                if (isDone) {
                    listItem.classList.add('meeting-item-done');
                }
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = isDone;
                checkbox.disabled = true; // Read-only checkboxes
                listItem.appendChild(checkbox);
                
                const itemContent = document.createElement('div');
                
                const clinic = document.createElement('div');
                clinic.className = 'meeting-clinic';
                clinic.textContent = item.Clinic;
                itemContent.appendChild(clinic);
                
                const metric = document.createElement('div');
                metric.className = 'meeting-metric';
                metric.textContent = item.Metric;
                itemContent.appendChild(metric);
                
                const notes = document.createElement('div');
                notes.className = 'meeting-notes';
                notes.textContent = item.Notes;
                itemContent.appendChild(notes);
                
                listItem.appendChild(itemContent);
                checklist.appendChild(listItem);
            });
            
            meetingBox.appendChild(checklist);
            container.appendChild(meetingBox);
        });
    }
    
    }

    // Parse data rows
    const data = [];
    for (let i = 1; i < lines.length; i++) {
        if (!lines[i].trim()) continue; // Skip empty lines

        // Handle quoted fields with commas inside them
        const row = parseCSVRow(lines[i]);

        if (row.length !== headers.length) {
            console.warn(`Skipping row ${i+1}: incorrect number of fields`);
            continue;
        
        // Split into lines and get headers
        const lines = csvText.split('\n');
        if (lines.length <= 1) {
            console.error("No valid data in meeting notes CSV");
            return [];
        }
        
        const headers = lines[0].split(',').map(header => header.trim());
        
        // Check for required headers
        const requiredHeaders = ['Date of meeting', 'Done', 'Clinic', 'Metric', 'Notes'];
        const missingHeaders = requiredHeaders.filter(header => !headers.includes(header));
        
        if (missingHeaders.length > 0) {
            console.error(`Missing required headers in meeting notes CSV: ${missingHeaders.join(', ')}`);
            return [];
        }
        
        // Parse data rows
        const data = [];
        for (let i = 1; i < lines.length; i++) {
            if (!lines[i].trim()) continue; // Skip empty lines
            
            // Handle quoted fields with commas inside them
            const row = parseCSVRow(lines[i]);
            
            if (row.length !== headers.length) {
                console.warn(`Skipping row ${i+1}: incorrect number of fields`);
                continue;
            }
            
            const item = {};
            headers.forEach((header, index) => {
                item[header] = row[index];
            });
            
            data.push(item);
        }
        
        console.log(`Parsed ${data.length} meeting note items`);
        return data;
    }
    
    // Helper function to properly parse CSV rows with quoted fields
    function parseCSVRow(row) {
        const result = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < row.length; i++) {
            const char = row[i];
            
            if (char === '"') {
                inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
            } else {
                current += char;
            }
        }
        
        result.push(current.trim());
        return result;
    }
    
    async function initializeMeetingNotesTab() {
        console.log("Initializing Meeting Notes tab...");
        
        try {
            // Fetch meeting notes data
            meetingNotesData = await fetchMeetingNotesData();
            
            // Setup filters
            populateMeetingNotesFilters();
            
            // Display meeting notes
            displayMeetingNotes();
            
            // Add event listener to the Apply Filters button
            document.getElementById('applyMeetingFilters').addEventListener('click', displayMeetingNotes);
            
            console.log("Meeting Notes tab initialized successfully");
        } catch (error) {
            console.error("Error initializing Meeting Notes tab:", error);
            document.getElementById('meetingNotesContainer').innerHTML = 
                '<p class="error">Failed to load meeting notes. Please try refreshing the page.</p>';
        }
    }
    
    // Initialize Meeting Notes tab when dashboard loads
    document.addEventListener('DOMContentLoaded', function() {
        // This will be added to the existing initialization code
        // For now we'll just call it here for testing
        setTimeout(initializeMeetingNotesTab, 1000);
    });
    
    // Function to initialize the daily date range picker
    function initializeDailyRangePicker() {
        console.log('Initializing daily date range picker...');
        $('#dateRangePickerDaily').daterangepicker({
            opens: 'left',
            autoApply: true,
            startDate: moment().subtract(2, 'weeks'),
            endDate: moment(),
            locale: {
                format: 'MM/DD/YYYY'
            }
        });
        console.log('Daily date range picker initialized');
    }
    
    // Function to render daily current data
    function renderDailyCurrent() {
        console.log('Rendering daily current data...');
        try {
            // Update daily metric dropdown
            updateDailyMetricSelector();
            
            // Render the daily pivot table
            renderDailyPivot();
            
            console.log('Daily data rendered successfully');
        } catch (error) {
            console.error('Error rendering daily data:', error);
            document.getElementById('dailyTableBody').innerHTML = '<tr><td colspan="4">Error loading daily data</td></tr>';
        }
    }
    
    // Function to update daily metric selector
    function updateDailyMetricSelector() {
        console.log('Updating daily metric selector...');
        const metricSelector = document.getElementById('dailyMetricSelector');
        if (!metricSelector) {
            console.warn('Daily metric selector not found');
            return;
        }
        
        // Save current selection if any
        const currentSelection = metricSelector.value;
        
        // Clear and repopulate the dropdown
        metricSelector.innerHTML = '';
        
        // Add metric options for metrics that have numerical values
        const numericalMetrics = metricsDefinition.filter(m => 
            m.type === 'percentage' || m.type === 'number');
            
        numericalMetrics.forEach(metric => {
            const option = document.createElement('option');
            option.value = metric.id;
            option.textContent = metric.name;
            metricSelector.appendChild(option);
        });
        
        // Restore previous selection if it exists
        if (currentSelection && metricSelector.querySelector(`option[value="${currentSelection}"]`)) {
            metricSelector.value = currentSelection;
        }
        
        // Add change event listener
        metricSelector.onchange = renderDailyPivot;
        
        console.log('Daily metric selector updated');
    }
    
    // Function to render daily pivot table
    function renderDailyPivot() {
        console.log('Rendering daily pivot table...');
        
        // Get selected metric from dropdown
        const metricSelector = document.getElementById('dailyMetricSelector');
        if (!metricSelector) {
            console.warn('Daily metric selector not found');
            return;
        }
        
        const selectedMetric = metricSelector.value;
        const metricName = metricSelector.options[metricSelector.selectedIndex].text;
        
        // Get date range if available
        let startDate = null;
        let endDate = null;
        
        const dateRangePicker = document.getElementById('dateRangePickerDaily');
        if (dateRangePicker && dateRangePicker.value) {
            const dates = dateRangePicker.value.split(' - ');
            if (dates.length === 2) {
                startDate = moment(dates[0], 'MM/DD/YYYY');
                endDate = moment(dates[1], 'MM/DD/YYYY');
            }
        }
        
        // If no date range selected, use last 14 days
        if (!startDate || !endDate) {
            endDate = moment();
            startDate = moment().subtract(14, 'days');
        }
        
        // Get daily data for all clinics
        if (!allClinicsDailyData || Object.keys(allClinicsDailyData).length === 0) {
            document.getElementById('dailyTableBody').innerHTML = '<tr><td colspan="8">No daily data available</td></tr>';
            return;
        }
        
        // Flatten all clinic data
        let allDailyData = [];
        for (const clinic in allClinicsDailyData) {
            allDailyData = allDailyData.concat(allClinicsDailyData[clinic] || []);
        }
        
        // Filter data by date range with flexible date parsing
        const filteredData = allDailyData.filter(entry => {
            if (!entry.Date) return false;
            // Try parsing multiple date formats
            const entryDate = moment(entry.Date, ['MM/DD/YYYY', 'YYYY-MM-DD', 'DD/MM/YYYY'], true);
            return entryDate.isValid() && entryDate.isSameOrAfter(startDate) && entryDate.isSameOrBefore(endDate);
        });
        
        if (!filteredData.length) {
            document.getElementById('dailyTableBody').innerHTML = '<tr><td colspan="8">No data available for the selected date range</td></tr>';
            return;
        }
        
        // Group data by date
        const dateGroups = {};
        filteredData.forEach(entry => {
            const date = entry.Date;
            if (!dateGroups[date]) {
                dateGroups[date] = [];
            }
            dateGroups[date].push(entry);
        });
        
        // Sort dates
        const sortedDates = Object.keys(dateGroups).sort((a, b) => {
            return moment(a, 'MM/DD/YYYY').diff(moment(b, 'MM/DD/YYYY'));
        });
        
        // Create table header
        let headerHtml = '<tr><th>Date</th><th>Clinic</th><th>Value</th><th>Target</th><th>Status</th></tr>';
        document.getElementById('dailyTableHead').innerHTML = headerHtml;
        
        // Create table body
        let bodyHtml = '';
        sortedDates.forEach(date => {
            const entries = dateGroups[date];
            if (entries && entries.length > 0) {
                entries.forEach(entry => {
                    // Get the metric value and benchmark
                    const value = parseFloat(entry[selectedMetric]) || 0;
                    let target = 0;
                    
                    // Get benchmark for this metric if available
                    if (dailyBenchmarkData && dailyBenchmarkData[selectedMetric]) {
                        target = parseFloat(dailyBenchmarkData[selectedMetric]) || 0;
                    }
                    
                    // Determine status based on value vs target
                    let statusClass = 'alert-normal';
                    let statusText = 'Normal';
                    
                    const higherIsBetter = true; // Modify this logic based on metric definition
                    
                    if (higherIsBetter) {
                        if (value < target * 0.7) {
                            statusClass = 'alert-critical';
                            statusText = 'Critical';
                        } else if (value < target * 0.9) {
                            statusClass = 'alert-high';
                            statusText = 'Alert';
                        } else if (value < target * 0.95) {
                            statusClass = 'alert-low';
                            statusText = 'Warning';
                        }
                    } else {
                        if (value > target * 1.3) {
                            statusClass = 'alert-critical';
                            statusText = 'Critical';
                        } else if (value > target * 1.1) {
                            statusClass = 'alert-high';
                            statusText = 'Alert';
                        } else if (value > target * 1.05) {
                            statusClass = 'alert-low';
                            statusText = 'Warning';
                        }
                    }
                    
                    bodyHtml += `<tr>
                        <td class="pivot-date">${date}</td>
                        <td class="pivot-clinic">${entry.Clinic}</td>
                        <td class="pivot-value">${value}</td>
                        <td class="pivot-target">${target}</td>
                        <td><span class="alert-badge ${statusClass}">${statusText}</span></td>
                    </tr>`;
                });
            }
        });
        
        document.getElementById('dailyTableBody').innerHTML = bodyHtml || '<tr><td colspan="5">No data available</td></tr>';
        console.log('Daily pivot table rendered successfully');
    }
</script>
    
    <!-- Meeting Notes Tab -->
    <div id="meetingNotesTab" class="tab-content">
        <h2>Meeting Notes</h2>
        <div class="controls">
            <div class="filter-group">
                <label for="meetingDateFilter">Date Range:</label>
                <input type="text" id="meetingDateFilter" class="date-range-picker">
            </div>
            <div class="filter-group">
                <label for="meetingClinicFilter">Clinic:</label>
                <select id="meetingClinicFilter">
                    <option value="all">All Clinics</option>
                    <!-- Will be populated dynamically -->
                </select>
            </div>
            <div class="filter-group">
                <label for="meetingMetricFilter">Metric:</label>
                <select id="meetingMetricFilter">
                    <option value="all">All Metrics</option>
                    <!-- Will be populated dynamically -->
                </select>
            </div>
            <div class="filter-group">
                <label for="meetingStatusFilter">Status:</label>
                <select id="meetingStatusFilter">
                    <option value="all">All</option>
                    <option value="done">Done</option>
                    <option value="not-done">Not Done</option>
                </select>
            </div>
            <button id="applyMeetingFilters" class="action-button">Apply Filters</button>
        </div>
        <div id="meetingNotesContainer" class="meeting-notes-container">
            <!-- Meeting notes will be populated here -->
            <div class="loading-indicator">Loading meeting notes...</div>
        </div>
    </div>
</body>
    </html>
    
