<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clinic Metrics Alert Dashboard (Dual Sheet)</title>
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.css" />
    <style>
        :root {
            --primary-bg: #f5f5f5;
            --primary-text: #333;
            --header-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --white: #fff;
            --shadow: 0 2px 10px rgba(0,0,0,0.1);
            --yellow-light: #fffbe6;
            --yellow-border: #ffe58f;
            --yellow-dark: #faad14;
            --red: #cf1322;
            --green: #389e0d;
            --critical: #e74c3c;
            --high: #f39c12;
            --low: #f1c40f;
            --normal: #27ae60;
            --slight: #1890ff;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--primary-bg);
            color: var(--primary-text);
        }
        .header { background: var(--header-gradient); color: var(--white); padding: 20px; text-align: center; box-shadow: var(--shadow); }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .last-updated { font-size: 0.9em; opacity: 0.9; }
        .controls {
            background: var(--white);
            padding: 20px;
            margin: 20px;
            border-radius: 10px;
            box-shadow: var(--shadow);
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        .filter-group { display: flex; flex-direction: column; gap: 5px; }
        .filter-group label { font-weight: bold; font-size: 0.9em; }
        .filter-group select, .filter-group input {
            padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 0.9em;
        }
        .summary-cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin: 20px; }
        .summary-card { background: var(--white); padding: 20px; border-radius: 10px; box-shadow: var(--shadow); text-align: center; }
        .summary-card h3 { font-size: 0.9em; color: #666; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
        .summary-card .number { font-size: 2.5em; font-weight: bold; margin-bottom: 5px; }
        .critical { color: var(--critical); }
        .high { color: var(--high); }
        .low { color: var(--low); }
        .normal { color: var(--normal); }
        .main-table { margin: 20px; background: var(--white); border-radius: 10px; box-shadow: var(--shadow); overflow: hidden; }
        .table-header { background: var(--header-gradient); color: var(--white); padding: 15px 20px; font-weight: bold; font-size: 1.1em; display: flex; justify-content: space-between; align-items: center; }
        .view-toggle { display: flex; gap: 10px; }
        .view-toggle button { background-color: rgba(255, 255, 255, 0.2); border: none; color: var(--white); padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8em; transition: background-color 0.3s; }
        .view-toggle button.active { background-color: rgba(255,255,255,0.4); font-weight: bold; }
        .view-toggle button:hover { background-color: rgba(255,255,255,0.3); }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #eee; font-size: 0.9em; }
        th { background-color: #f8f9fa; font-weight: bold; position: sticky; top: 0; z-index: 10; }
        th:first-child, td:first-child { position: sticky; left: 0; background-color: #f8f9fa; z-index: 11; }
        th:first-child { z-index: 12; }
        tbody tr:hover { background-color: #f8f9fa; }
        .alert-badge { padding: 4px 8px; border-radius: 12px; font-size: 0.8em; font-weight: bold; text-align: center; min-width: 60px; display: inline-block; }
        .alert-critical { background-color: var(--critical); color: var(--white);}
        .alert-high { background-color: var(--high); color: var(--white);}
        .alert-low { background-color: var(--low); color: #333;}
        .alert-slight { background-color: var(--slight); color: var(--white);}
        .alert-normal { background-color: var(--normal); color: var(--white);}
        .trend-arrow { font-size: 1.2em; margin-left: 5px; }
        .trend-up { color: var(--normal);}
        .trend-down { color: var(--critical);}
        .trend-same { color: #95a5a6; }
        .clinic-name { font-weight: bold; color: #2c3e50; }
        .metric-value { text-align: center; }
        .deviation { font-size: 0.8em; color: #666; }
        .action-button { background-color: #3498db; color: var(--white); border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8em; }
        .action-button:hover { background-color: #2980b9; }
        .loading-overlay {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(255,255,255,0.8);
            display: flex; justify-content: center; align-items: center;
            z-index: 2000;
        }
        .loading-overlay[hidden] { display: none; }
        .spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px; height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg);} 100% {transform: rotate(360deg);} }
        @media (max-width: 768px) {
            .controls { flex-direction: column; align-items: stretch; }
            .summary-cards { grid-template-columns: 1fr; }
            .main-table { font-size: 0.8em;}
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div>
            <div class="spinner"></div>
            <p id="loadingMessage">Loading Dashboard Data...</p>
        </div>
    </div>
    <div class="header">
        <h1>Clinic Metrics Alert Dashboard</h1>
        <div class="last-updated" id="lastUpdated" aria-live="polite">Loading...</div>
    </div>
    <div class="controls" aria-label="Dashboard Controls">
        <div class="filter-group">
            <label for="alertFilter">Filter by Alert Level:</label>
            <select id="alertFilter" onchange="filterTable()" aria-label="Filter by Alert Level" disabled>
                <option value="all">All Alerts</option>
                <option value="critical">Critical Only</option>
                <option value="high">High Only</option>
                <option value="low">Low Only</option>
                <option value="slight">Slight Only</option>
                <option value="normal">Normal Only</option>
            </select>
        </div>
        <div class="filter-group">
            <label for="clinicFilter">Filter by Clinic:</label>
            <select id="clinicFilter" onchange="filterTable()" aria-label="Filter by Clinic" disabled>
                <option value="all">All Clinics</option>
            </select>
        </div>
        <div class="filter-group">
            <label for="searchInput">Search Clinic:</label>
            <input type="text" id="searchInput" placeholder="Type clinic name..." aria-label="Search Clinic" disabled>
        </div>
        <div class="filter-group">
            <label for="timePeriodFilter">Time Period:</label>
            <select id="timePeriodFilter" onchange="changeTimePeriod()" aria-label="Time Period" disabled>
            </select>
        </div>
        <div class="filter-group">
            <label for="exportBtn">Export Data:</label>
            <button class="action-button" id="exportBtn" onclick="exportData()" aria-label="Export to CSV" disabled>Export to CSV</button>
        </div>
    </div>
    <div class="summary-cards" id="summaryCards">
        <div class="summary-card"><p>Loading data...</p></div>
    </div>
    <div class="main-table" aria-label="Clinic Metrics Table">
        <div class="table-header">
            <div id="tableTitle">Clinic Performance Overview</div>
            <div class="view-toggle" role="tablist" aria-label="View Toggle">
                <button class="active" onclick="toggleView('table')" aria-selected="true" disabled>Table View</button>
                <button onclick="toggleView('cards')" aria-selected="false" disabled>Card View</button>
            </div>
        </div>
        <div class="responsive-table" id="tableView">
            <table id="metricsTable">
                <thead>
                    <tr>
                        <th>Clinic</th>
                        <th>Notes Alert</th>
                        <th>New Patients</th>
                        <th>Visits Target</th>
                        <th>Daily Dist</th>
                        <th>Utilization</th>
                        <th>Retention (2nd)</th>
                        <th>Retention (5th)</th>
                        <th>Retention (10th)</th>
                        <th>Retention (15th)</th>
                        <th>Cancel</th>
                        <th>No Show</th>
                        <th>No Upcoming</th>
                        <th>Units</th>
                        <th>Insurance Coding</th>
                        <th>Support Coding</th>
                        <th>Confirmation</th>
                        <th>Direct Access</th>
                        <th>Survey</th>
                        <th>Satisfaction</th>
                        <th>Overall</th>
                        <th>Trend</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody id="tableBody">
                    <tr><td colspan="23" style="text-align: center;">Loading data...</td></tr>
                </tbody>
            </table>
        </div>
        <div id="cardView" style="display: none; padding: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
        </div>
    </div>
    <!-- (tabs and details panel may be included as in your original) -->

    <!-- Load scripts at the end for faster rendering -->
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/latest/jquery.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/momentjs/latest/moment.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.min.js"></script>
    <script>
    // Debounce utility for search input
    function debounce(func, delay) {
        let timeout; return function() {
            const context = this, args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), delay);
        };
    }
    // Show/hide loading overlay
    function showLoading(msg) {
        document.getElementById('loadingOverlay').hidden = false;
        document.getElementById('loadingMessage').innerText = msg || 'Loading...';
    }
    function hideLoading() {
        document.getElementById('loadingOverlay').hidden = true;
    }
    function enableControls() {
        ['alertFilter','clinicFilter','searchInput','timePeriodFilter','exportBtn'].forEach(id=>{
            const el=document.getElementById(id); if(el) el.disabled=false;
        });
    }
    function disableControls() {
        ['alertFilter','clinicFilter','searchInput','timePeriodFilter','exportBtn'].forEach(id=>{
            const el=document.getElementById(id); if(el) el.disabled=true;
        });
    }
    // Debounced search input
    document.addEventListener('DOMContentLoaded', () => {
        const input = document.getElementById('searchInput');
        if(input) input.addEventListener('keyup', debounce(filterTable, 250));
    });

    // --- Full dashboard logic from your original index.html follows ---
    // (copy everything from your main script in index.html, starting with the Google Charts setup,
    // data fetching, parsing, populating, rendering, etc.)
    // Example: (abbreviated for clarity, use your full code!)
    google.charts.load('current', {'packages':['corechart', 'line', 'table']});
    google.charts.setOnLoadCallback(setupDashboard);

    // --- Configuration ---
    const googleSheetDataUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQeN0UumxiDN3Qp5H8J0bKZOvkMgRBvNe-G8KYja32gNGE_Rws90BGR4EShDrpXoqWiuZpnfaKmrAzN/pub?gid=0&single=true&output=csv';
    const googleSheetBenchmarkUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQeN0UumxiDN3Qp5H8J0bKZOvkMgRBvNe-G8KYja32gNGE_Rws90BGR4EShDrpXoqWiuZpnfaKmrAzN/pub?gid=1294580086&single=true&output=csv';



    <script>
        // Load Google Charts
        google.charts.load('current', {'packages':['corechart', 'line', 'table']});
        google.charts.setOnLoadCallback(setupDashboard);

        // --- Configuration ---
        // HARDCODED Google Sheet URLs - Replace these if your published sheet URLs change
        const googleSheetDataUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQeN0UumxiDN3Qp5H8J0bKZOvkMgRBvNe-G8KYja32gNGE_Rws90BGR4EShDrpXoqWiuZpnfaKmrAzN/pub?gid=0&single=true&output=csv'; 
        const googleSheetBenchmarkUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQeN0UumxiDN3Qp5H8J0bKZOvkMgRBvNe-G8KYja32gNGE_Rws90BGR4EShDrpXoqWiuZpnfaKmrAzN/pub?gid=1294580086&single=true&output=csv'; 

        // --- Data Definitions ---
        // Note: AreaManagerNotes removed, AreaManagerNotesAlert kept (no benchmark)
        const metricsDefinition = [
            // { id: 'areaManagerNotes', name: 'Area Manager Notes', target: null, higherIsBetter: null, type: 'text' }, // Removed
            { id: 'newPatients', name: 'New Patients %', type: 'percentage' },
            { id: 'visitsTarget', name: 'Visits Target %', type: 'percentage' },
            { id: 'dailyDistribution', name: 'Daily Distribution', type: 'number' }, 
            { id: 'utilization', name: 'Utilization Rate %', type: 'percentage' },
            { id: 'retention2nd', name: 'Retention 2nd %', type: 'percentage' },
            { id: 'retention5th', name: 'Retention 5th %', type: 'percentage' },
            { id: 'retention10th', name: 'Retention 10th %', type: 'percentage' },
            { id: 'retention15th', name: 'Retention 15th %', type: 'percentage' },
            { id: 'cancel', name: 'Cancel %', type: 'percentage' },
            { id: 'noShow', name: 'No Show %', type: 'percentage' },
            { id: 'noUpcoming', name: 'No Upcoming %', type: 'percentage' },
            { id: 'units', name: 'Units %', type: 'percentage' },
            { id: 'insuranceCoding', name: 'Insurance Utilization Coding %', type: 'percentage' },
            { id: 'supportiveCoding', name: 'Supportive Coding %', type: 'percentage' },
            { id: 'confirmation', name: 'Confirmation %', type: 'percentage' },
            { id: 'directAccess', name: 'Direct Access %', type: 'percentage' },
            { id: 'surveyCollection', name: 'Survey Collection %', type: 'percentage' },
            { id: 'satisfaction', name: 'Hospitality/Clinical Satisfaction %', type: 'percentage' }
        ];
        // Expected headers for the DATA sheet
        const expectedDataCsvHeaders = [
            'Clinic', 'Date of week', 'Year', 'AreaManagerNotesAlert',
            'NewPatients', 'VisitsTarget', 'DailyDistribution', 'Utilization', 
            'Retention2nd', 'Retention5th', 'Retention10th', 'Retention15th', 
            'Cancel', 'NoShow', 'NoUpcoming', 'Units', 'InsuranceCoding', 
            'SupportiveCoding', 'Confirmation', 'DirectAccess', 'SurveyCollection', 'Satisfaction'
        ];
        // Expected headers for the BENCHMARK sheet (Metric names + _HigherIsBetter)
        const expectedBenchmarkCsvHeaders = [
            'Year', 'Week',
            ...metricsDefinition.map(m => m.id.charAt(0).toUpperCase() + m.id.slice(1)), // Metric names (e.g., NewPatients)
            ...metricsDefinition.map(m => m.id.charAt(0).toUpperCase() + m.id.slice(1) + '_HigherIsBetter') // HigherIsBetter flags
        ];

        // --- Global Variables ---
        let allClinicsData = {}; // Stores processed data keyed by clinic name { clinicName: [weekData1, weekData2,...] }
        let benchmarkData = {}; // Stores benchmark data keyed by 'Year-Week' { '2024-23': { NewPatients: 90, NewPatients_HigherIsBetter: true, ... } }
        let currentWeekData = []; // Data for the currently selected week/period
        let displayedData = []; // Data currently shown in the table/cards after filtering
        let availableWeeks = []; // Array of {year, week, date} objects found in data
        let latestWeek = { year: 0, week: 0, date: null };
        let previousWeek = { year: 0, week: 0, date: null };
        let currentView = 'table';
        let selectedMetric = 'newPatients'; // Default metric for historical charts
        let selectedClinic = 'all'; // Default clinic for historical charts
        let trendChart;
        let comparisonChart;
        let dateRange = {
            start: moment().subtract(8, 'weeks'),
            end: moment()
        };
        let validationMessages = []; // Store validation messages

        // --- Core Functions ---

        // Initial setup function called after Google Charts loads
        function setupDashboard() {
            console.log("Dashboard setup initiated.");
            initializeDatePickers(); 
            populateMetricSelector();
            
            if (googleSheetDataUrl && googleSheetBenchmarkUrl) {
                 console.log(`Attempting to autoload data from: ${googleSheetDataUrl}`);
                 console.log(`Attempting to autoload benchmarks from: ${googleSheetBenchmarkUrl}`);
                 initializeDashboard(); // Start the main data loading and processing sequence
            } else {
                 addValidationMessage('error', "Configuration Error: Data or Benchmark Google Sheet URL is not configured in the script.");
                 displayValidationMessages();
                 hideLoading("Configuration Error");
                 disableControls();
            }
        }
        
        // Main function to fetch, process, and display data
        async function initializeDashboard() {
            console.log("Initializing dashboard with data fetch...");
            showLoading("Fetching data and benchmarks...");
            validationMessages = []; // Clear previous validation messages
            allClinicsData = {}; // Reset data
            benchmarkData = {};
            availableWeeks = [];
            latestWeek = { year: 0, week: 0, date: null };
            previousWeek = { year: 0, week: 0, date: null };
            
            try {
                // Fetch both sheets concurrently
                const [csvDataText, csvBenchmarkText] = await Promise.all([
                    fetchDataFromSheet(googleSheetDataUrl, 'Data'),
                    fetchDataFromSheet(googleSheetBenchmarkUrl, 'Benchmark')
                ]);
                
                showLoading("Processing benchmarks...");
                const parsedBenchmarks = parseBenchmarkCSVData(csvBenchmarkText);
                if (!parsedBenchmarks || Object.keys(parsedBenchmarks).length === 0) {
                    addValidationMessage('warning', "No valid benchmark data found or processed. Using default fallback benchmarks.");
                    // Proceed without benchmarks or use defaults? For now, proceed and handle missing benchmarks later.
                } else {
                     benchmarkData = parsedBenchmarks;
                     addValidationMessage('success', `Successfully processed ${Object.keys(benchmarkData).length} weeks of benchmark data.`);
                }
                
                showLoading("Processing clinic data...");
                const parsedData = parseCSVData(csvDataText);
                if (!parsedData || parsedData.length === 0) {
                    throw new Error("No valid clinic data found or processed from the Data sheet.");
                }
                addValidationMessage('success', `Successfully processed ${parsedData.length} clinic data entries.`);
                
                showLoading("Calculating alerts and trends...");
                processAndStoreData(parsedData); // Pass benchmarkData implicitly (it's global)
                
                if (availableWeeks.length === 0) {
                     throw new Error("No valid weekly data could be processed after applying benchmarks and validation.");
                }

                // Set initial time period to the latest week
                currentWeekData = getDataForWeek(latestWeek.year, latestWeek.week);
                displayedData = currentWeekData;

                // Update UI elements
                populateTimePeriodFilter();
                populateClinicOptions();
                populateWeekSelectors(); // For comparison tab
                updateSummaryCards(displayedData);
                populateTable(displayedData);
                populateCardView(displayedData);
                updateLastUpdated();
                updateHistoricalCharts(); // Initial chart draw
                enableControls(); // Enable UI controls now that data is loaded
                
                console.log("Dashboard Initialized Successfully.");
                // displayValidationMessages(); // Validation messages hidden on success
                hideLoading();

            } catch (error) {
                console.error("Dashboard Initialization Failed:", error);
                addValidationMessage('error', `Initialization Failed: ${error.message}`);
                displayValidationMessages();
                hideLoading(`Error: ${error.message}`);
                disableControls(); // Keep controls disabled on error
            }
        }

        // Fetch data from a Google Sheet URL
        async function fetchDataFromSheet(url, sheetName) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    // Provide more specific error based on status code
                    let errorMsg = `Failed to fetch ${sheetName} sheet. Status: ${response.status} ${response.statusText}.`;
                    if (response.status === 404) {
                        errorMsg += " Please ensure the URL is correct and the sheet is published as CSV.";
                    } else if (response.status === 403) {
                         errorMsg += " Access denied. Ensure the sheet is published correctly ('Anyone with the link').";
                    } else {
                         errorMsg += " Check network connection and URL.";
                    }
                    throw new Error(errorMsg);
                }
                const csvText = await response.text();
                if (!csvText || csvText.trim().length === 0) {
                     throw new Error(`Fetched CSV data for ${sheetName} sheet is empty.`);
                }
                console.log(`${sheetName} CSV Data fetched successfully.`);
                return csvText;
            } catch (error) {
                console.error(`Fetch Error (${sheetName}):`, error);
                // Distinguish network errors from fetch failures
                if (error instanceof TypeError) { // Likely a network error (e.g., CORS if run locally)
                     throw new Error(`Network error fetching ${sheetName} sheet: ${error.message}. If running locally, try using a local server (e.g., 'python -m http.server').`);
                } else {
                     throw new Error(`Error fetching ${sheetName} sheet: ${error.message}`);
                }
            }
        }
        
        // Robust CSV row parser (handles quoted commas)
        function parseCsvRow(rowString) {
            const values = [];
            let currentVal = '';
            let inQuotes = false;
            for (let i = 0; i < rowString.length; i++) {
                const char = rowString[i];
                if (char === '"') {
                    if (inQuotes && rowString[i+1] === '"') {
                        // Escaped quote
                        currentVal += '"';
                        i++; // Skip next quote
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    values.push(currentVal.trim());
                    currentVal = '';
                } else {
                    currentVal += char;
                }
            }
            values.push(currentVal.trim()); // Add the last value
            return values;
        }

        // Parse Clinic Data CSV text into an array of objects
        function parseCSVData(csvText) {
            console.log("Parsing Clinic Data CSV...");
            const lines = csvText.trim().split(/\r?\n/);
            if (lines.length < 2) {
                addValidationMessage('error', "Clinic Data CSV Error: Must have at least a header row and one data row.");
                return [];
            }
            
            const headers = lines[0].split(',').map(h => h.trim());
            console.log("Data CSV Headers:", headers);

            // Validate headers
            const missingHeaders = expectedDataCsvHeaders.filter(h => !headers.includes(h));
            if (missingHeaders.length > 0) {
                addValidationMessage('error', `Clinic Data CSV Error: Missing required columns: ${missingHeaders.join(', ')}.`);
                // Continue parsing with available columns, but warn user
            }
            const extraHeaders = headers.filter(h => !expectedDataCsvHeaders.includes(h));
             if (extraHeaders.length > 0) {
                 addValidationMessage('warning', `Clinic Data CSV Warning: Found unexpected columns: ${extraHeaders.join(', ')}. These will be ignored.`);
             }
            
            const data = [];
            let skippedRowCount = 0;
            for (let i = 1; i < lines.length; i++) {
                const rowNum = i + 1;
                if (!lines[i].trim()) continue; // Skip empty lines
                
                const values = parseCsvRow(lines[i]); 
                if (values.length !== headers.length) {
                     addValidationMessage('warning', `Clinic Data CSV Warning (Row ${rowNum}): Skipped row due to incorrect number of columns (${values.length} found, ${headers.length} expected). Line: '${lines[i]}'`);
                     skippedRowCount++;
                     continue;
                }
                
                const entry = {};
                let validEntry = true;
                let rowErrors = [];
                for (let j = 0; j < headers.length; j++) {
                    const header = headers[j];
                    // Only process expected headers
                    if (!expectedDataCsvHeaders.includes(header)) continue;
                    
                    let value = values[j];
                    
                    // Basic type conversion and validation
                    if (header === 'Year') {
                        const num = parseInt(value);
                        if (isNaN(num) || value.trim() === '') {
                            rowErrors.push(`Invalid/missing value for ${header}: '${value}'`);
                            validEntry = false;
                            entry[header] = null; // Store as null
                        } else {
                            entry[header] = num;
                        }
                    } else if (header === 'Date of week') {
                        // Parse date (assuming format like MM/DD/YYYY or ISO)
                        const parsedDate = moment(value, ['MM/DD/YYYY', 'YYYY-MM-DD']);
                        if (!parsedDate.isValid() || value.trim() === '') {
                            rowErrors.push(`Invalid/missing value for ${header}: '${value}'`);
                            validEntry = false;
                            entry[header] = null;
                        } else {
                            entry[header] = parsedDate.format('YYYY-MM-DD');
                            // Derive week number from date
                            entry['Week'] = parsedDate.isoWeek();
                        }
                    } else if (header === 'Clinic' || header === 'AreaManagerNotesAlert') {
                        if (!value || value.trim() === '') {
                             if (header === 'Clinic') { // Clinic is essential
                                 rowErrors.push(`Missing essential value for ${header}`);
                                 validEntry = false;
                             }
                             entry[header] = null; // Allow missing alert
                        } else {
                             entry[header] = value; // Keep as string
                        }
                    } else {
                        // Assume other metrics are numbers (handle empty strings/non-numeric as null)
                        const num = parseFloat(value);
                        if (value.trim() === '') {
                             entry[header] = null; // Treat empty as null
                        } else if (isNaN(num)) {
                             rowErrors.push(`Invalid non-numeric value for metric ${header}: '${value}'`);
                             entry[header] = null; // Treat invalid number as null
                             // Don't mark entry as invalid, just the value
                        } else {
                             entry[header] = num;
                        }
                    }
                }
                
                // Check for essential fields (Clinic, Date of week, Year)
                if (!entry['Clinic'] || entry['Date of week'] === null || entry['Year'] === null) {
                     validEntry = false;
                     rowErrors.push("Missing essential Clinic, Date of week, or Year");
                }
                
                if (validEntry) {
                     if (rowErrors.length > 0) {
                         // Add entry but log warnings for specific fields
                         addValidationMessage('warning', `Clinic Data CSV Warning (Row ${rowNum}, Clinic: ${entry['Clinic'] || 'N/A'}): Processed row with issues: ${rowErrors.join('; ')}.`);
                     }
                     data.push(entry);
                } else {
                     addValidationMessage('warning', `Clinic Data CSV Warning (Row ${rowNum}): Skipped row due to critical errors: ${rowErrors.join('; ')}.`);
                     skippedRowCount++;
                }
            }
            console.log(`Parsed ${data.length} valid data entries. Skipped ${skippedRowCount} rows.`);
            if (skippedRowCount > 0) {
                 addValidationMessage('warning', `Skipped ${skippedRowCount} rows in the Clinic Data sheet due to formatting or missing essential data (Clinic, Date of week, Year). See console or validation messages for details.`);
            }
            if (data.length === 0 && lines.length > 1) {
                 addValidationMessage('error', "Clinic Data CSV Error: No valid data rows could be processed. Check sheet format and ensure Clinic, Date of week, and Year columns are present and valid.");
            }
            return data;
        }
        
        // Parse Benchmark CSV text into an object keyed by 'Year-Week'
        function parseBenchmarkCSVData(csvText) {
            console.log("Parsing Benchmark CSV...");
            const benchmarks = {};
            const lines = csvText.trim().split(/\r?\n/);
            if (lines.length < 2) {
                addValidationMessage('warning', "Benchmark CSV Warning: Sheet must have at least a header row and one data row. Using default benchmarks.");
                return {};
            }

            const headers = lines[0].split(',').map(h => h.trim());
            console.log("Benchmark CSV Headers:", headers);

            // Validate headers - check for Year, Week, and expected metric/flag columns
            const requiredBaseHeaders = ['Year', 'Week'];
            const missingBase = requiredBaseHeaders.filter(h => !headers.includes(h));
            if (missingBase.length > 0) {
                 addValidationMessage('error', `Benchmark CSV Error: Missing required columns: ${missingBase.join(', ')}. Cannot process benchmarks.`);
                 return {};
            }
            
            const expectedMetrics = metricsDefinition.map(m => m.id.charAt(0).toUpperCase() + m.id.slice(1));
            const expectedFlags = metricsDefinition.map(m => m.id.charAt(0).toUpperCase() + m.id.slice(1) + '_HigherIsBetter');
            const missingMetrics = expectedMetrics.filter(h => !headers.includes(h));
            const missingFlags = expectedFlags.filter(h => !headers.includes(h));
            
            if (missingMetrics.length > 0) {
                 addValidationMessage('warning', `Benchmark CSV Warning: Missing benchmark value columns: ${missingMetrics.join(', ')}. Alerts for these metrics may be inaccurate.`);
            }
             if (missingFlags.length > 0) {
                 addValidationMessage('warning', `Benchmark CSV Warning: Missing '_HigherIsBetter' flag columns: ${missingFlags.join(', ')}. Default direction (higher is better) will be assumed for these metrics.`);
            }
            const extraHeaders = headers.filter(h => !requiredBaseHeaders.includes(h) && !expectedMetrics.includes(h) && !expectedFlags.includes(h));
             if (extraHeaders.length > 0) {
                 addValidationMessage('warning', `Benchmark CSV Warning: Found unexpected columns: ${extraHeaders.join(', ')}. These will be ignored.`);
             }

            let skippedRowCount = 0;
            for (let i = 1; i < lines.length; i++) {
                const rowNum = i + 1;
                if (!lines[i].trim()) continue; // Skip empty lines

                const values = parseCsvRow(lines[i]);
                if (values.length !== headers.length) {
                    addValidationMessage('warning', `Benchmark CSV Warning (Row ${rowNum}): Skipped row due to incorrect number of columns (${values.length} found, ${headers.length} expected). Line: '${lines[i]}'`);
                    skippedRowCount++;
                    continue;
                }

                const entry = {};
                let year = NaN, week = NaN;
                let rowErrors = [];

                for (let j = 0; j < headers.length; j++) {
                    const header = headers[j];
                    const value = values[j];

                    if (header === 'Year') {
                        year = parseInt(value);
                        if (isNaN(year) || value.trim() === '') rowErrors.push("Invalid/missing Year");
                    } else if (header === 'Week') {
                        week = parseInt(value);
                        if (isNaN(week) || value.trim() === '') rowErrors.push("Invalid/missing Week");
                    } else if (expectedMetrics.includes(header)) {
                        // Benchmark value - should be number
                        const num = parseFloat(value);
                        if (value.trim() === '') {
                             entry[header] = null; // Allow missing benchmark
                        } else if (isNaN(num)) {
                             rowErrors.push(`Invalid non-numeric benchmark for ${header}: '${value}'`);
                             entry[header] = null;
                        } else {
                             entry[header] = num;
                        }
                    } else if (expectedFlags.includes(header)) {
                        // HigherIsBetter flag - should be TRUE/FALSE
                        const flag = value.trim().toUpperCase();
                        if (flag === 'TRUE') {
                            entry[header] = true;
                        } else if (flag === 'FALSE') {
                            entry[header] = false;
                        } else {
                             rowErrors.push(`Invalid boolean value for ${header}: '${value}' (expected TRUE or FALSE)`);
                             entry[header] = null; // Default to null if invalid
                        }
                    }
                    // Ignore extra headers
                }

                if (!isNaN(year) && !isNaN(week)) {
                    const key = `${year}-W${week}`;
                    if (rowErrors.length > 0) {
                         addValidationMessage('warning', `Benchmark CSV Warning (Row ${rowNum}, Week: ${key}): Processed row with issues: ${rowErrors.join('; ')}.`);
                    }
                    benchmarks[key] = entry;
                } else {
                    addValidationMessage('warning', `Benchmark CSV Warning (Row ${rowNum}): Skipped row due to missing/invalid Year or Week: ${rowErrors.join('; ')}.`);
                    skippedRowCount++;
                }
            }
            console.log(`Parsed ${Object.keys(benchmarks).length} valid benchmark weeks. Skipped ${skippedRowCount} rows.`);
             if (skippedRowCount > 0) {
                 addValidationMessage('warning', `Skipped ${skippedRowCount} rows in the Benchmark sheet due to formatting or missing Year/Week. See console or validation messages for details.`);
            }
            if (Object.keys(benchmarks).length === 0 && lines.length > 1) {
                 addValidationMessage('warning', "Benchmark CSV Warning: No valid benchmark rows could be processed. Default benchmarks will be used.");
            }
            return benchmarks;
        }

        // Process parsed data: calculate alerts, trends, group by clinic/week
        function processAndStoreData(parsedData) {
            console.log("Processing and storing data with dynamic benchmarks...");
            allClinicsData = {};
            availableWeeks = [];
            const weekSet = new Set();
            let processedEntryCount = 0;

            // Group data by clinic
            parsedData.forEach(entry => {
                const clinicName = entry.Clinic;
                if (!allClinicsData[clinicName]) {
                    allClinicsData[clinicName] = [];
                }
                allClinicsData[clinicName].push(entry);
                
                // Track available weeks
                const weekKey = `${entry.Year}-W${entry.Week}`;
                if (!weekSet.has(weekKey)) {
                    weekSet.add(weekKey);
                    availableWeeks.push({ year: entry.Year, week: entry.Week, date: entry['Date of week'] });
                }
            });

            // Sort available weeks chronologically by date
            availableWeeks.sort((a, b) => {
                const dateA = moment(a.date);
                const dateB = moment(b.date);
                return dateA.diff(dateB);
            });
            
            if (availableWeeks.length > 0) {
                latestWeek = availableWeeks[availableWeeks.length - 1];
                if (availableWeeks.length > 1) {
                    previousWeek = availableWeeks[availableWeeks.length - 2];
                }
            }
            console.log("Latest Week:", latestWeek, "Previous Week:", previousWeek);

            // Calculate alerts and trends for each entry using dynamic benchmarks
            Object.keys(allClinicsData).forEach(clinicName => {
                // Sort each clinic's history chronologically by date
                allClinicsData[clinicName].sort((a, b) => {
                    const dateA = moment(a['Date of week']);
                    const dateB = moment(b['Date of week']);
                    return dateA.diff(dateB);
                });

                // Calculate alerts and trends
                allClinicsData[clinicName].forEach((entry, index) => {
                    const prevEntry = index > 0 ? allClinicsData[clinicName][index - 1] : null;
                    const weekKey = `${entry.Year}-W${entry.Week}`;
                    const weeklyBenchmarks = benchmarkData[weekKey]; // Get benchmarks for this specific week
                    
                    if (!weeklyBenchmarks) {
                         addValidationMessage('warning', `Missing benchmarks for week ${weekKey}. Using fallback defaults for clinic ${clinicName}.`);
                    }
                    
                    let overallAlertCounts = { critical: 0, high: 0, low: 0, normal: 0 };
                    let trendImproving = 0;
                    let trendWorsening = 0;
                    let trendStable = 0;

                    // Handle AreaManagerNotesAlert first (no benchmark needed)
                    const notesAlertRaw = entry['AreaManagerNotesAlert'];
                    const notesAlert = (notesAlertRaw && ['critical', 'high', 'low', 'normal'].includes(notesAlertRaw.toLowerCase())) 
                                       ? notesAlertRaw.toLowerCase() : 'normal'; // Default to normal if missing/invalid
                    entry['areaManagerNotesAlertLevel'] = notesAlert; // Store the calculated level
                    overallAlertCounts[notesAlert]++;
                    trendStable++; // No trend for notes alert

                    // Process other metrics defined in metricsDefinition
                    metricsDefinition.forEach(metric => {
                        const metricId = metric.id;
                        const csvHeader = metricId.charAt(0).toUpperCase() + metricId.slice(1);
                        const value = entry[csvHeader]; // Get value from Data sheet
                        
                        // Get benchmark and direction from Benchmark sheet for this week
                        const benchmarkValue = weeklyBenchmarks ? weeklyBenchmarks[csvHeader] : null;
                        const higherIsBetterFlag = weeklyBenchmarks ? weeklyBenchmarks[csvHeader + '_HigherIsBetter'] : null;
                        // Fallback: Assume higher is better if flag is missing/invalid (could refine this)
                        const higherIsBetter = (higherIsBetterFlag === null || higherIsBetterFlag === undefined) ? true : higherIsBetterFlag;
                        
                        // Calculate alert level using dynamic benchmark
                        entry[metricId + 'Alert'] = getAlertLevel(value, benchmarkValue, higherIsBetter, metricId);
                        
                        // Calculate trend compared to previous week
                        if (prevEntry && prevEntry[csvHeader] !== null && value !== null) {
                            const prevValue = prevEntry[csvHeader];
                            if (value > prevValue) entry[metricId + 'Trend'] = 'up';
                            else if (value < prevValue) entry[metricId + 'Trend'] = 'down';
                            else entry[metricId + 'Trend'] = 'same';
                        } else {
                            entry[metricId + 'Trend'] = 'same'; // Default trend if no previous data or current data is null
                        }
                        
                        // Count alerts for overall calculation
                        if (entry[metricId + 'Alert']) {
                             overallAlertCounts[entry[metricId + 'Alert']]++;
                        }
                        
                        // Count trends for weekly trend calculation
                        if (entry[metricId + 'Trend'] === 'up') {
                            higherIsBetter ? trendImproving++ : trendWorsening++;
                        } else if (entry[metricId + 'Trend'] === 'down') {
                             higherIsBetter ? trendWorsening++ : trendImproving++;
                        } else {
                            trendStable++;
                        }
                    });

                    // Determine overall alert level based on count of high/critical metrics
                    const highCriticalCount = overallAlertCounts.critical + overallAlertCounts.high;
                    if (highCriticalCount >= 8) {
                        entry.overallAlert = 'critical';
                    } else if (highCriticalCount >= 6) { // 6 or 7
                        entry.overallAlert = 'high';
                    } else if (highCriticalCount >= 3) { // 3, 4, or 5
                        entry.overallAlert = 'normal';
                    } else { // 0, 1, or 2
                        entry.overallAlert = 'low';
                    }
                    
                    // Determine weekly trend
                    if (trendImproving > trendWorsening) entry.weeklyTrend = 'improving';
                    else if (trendWorsening > trendImproving) entry.weeklyTrend = 'worsening';
                    else entry.weeklyTrend = 'stable';
                    
                    processedEntryCount++;
                });
            });
            console.log(`Data processing complete. Processed ${processedEntryCount} entries.`);
        }
        
        // Get all data for a specific week
        function getDataForWeek(year, week) {
            const weekData = [];
            Object.keys(allClinicsData).forEach(clinicName => {
                const entry = allClinicsData[clinicName].find(d => d.Year === year && d.Week === week);
                if (entry) {
                    weekData.push(entry);
                }
            });
            return weekData;
        }

        // --- Helper Functions ---

        // Function to get trend arrow symbol
        function getTrendArrow(trend) {
            switch (trend) {
                case 'up': return '▲';
                case 'down': return '▼';
                case 'same': return '▬';
                default: return '';
            }
        }

        // Helper function to determine alert level using DYNAMIC benchmarks and custom deviation thresholds
        function getAlertLevel(value, target, higherIsBetter, metricId) {
            // Handle missing data or missing benchmarks gracefully
            if (value === null || value === undefined) return 'normal'; 
            if (target === null || target === undefined) {
                 console.warn(`Missing benchmark for metric '${metricId}' for the relevant week. Alert level defaulted to 'normal'.`); // Log to console instead of UI
                 return 'normal'; 
            }

            const benchmarkValue = parseFloat(target);
            const metricValue = parseFloat(value);

            // Check for invalid numbers or zero benchmark (avoid division by zero)
            if (isNaN(benchmarkValue) || isNaN(metricValue) || benchmarkValue === 0) {
                console.warn(`Invalid value or zero benchmark for metric '${metricId}' (Value: ${value}, Benchmark: ${target}). Alert level defaulted to 'normal'.`);
                return 'normal';
            }

            // Special handling for NoShow, NoUpcoming, Cancel, and DirectAccess
            const specialMetrics = ['noShow', 'noUpcoming', 'cancel', 'directAccess'];
            if (specialMetrics.includes(metricId)) {
                // For these metrics, lower than target is always good
                if (metricValue <= benchmarkValue) {
                    return 'normal'; // Below or equal to target is good
                }
                // Calculate deviation only if exceeding target
                const deviationPercent = ((metricValue - benchmarkValue) / benchmarkValue) * 100;
                if (deviationPercent <= 5) {
                    return 'normal';
                } else if (deviationPercent <= 10) {
                    return 'slight';
                } else if (deviationPercent <= 20) {
                    return 'low';
                } else if (deviationPercent <= 30) {
                    return 'high';
                } else {
                    return 'critical';
                }
            }

            // Standard alert calculation for other metrics
            const deviationPercent = Math.abs((metricValue - benchmarkValue) / benchmarkValue) * 100;

            // Apply alert thresholds based on deviation percentage
            if (deviationPercent <= 5) {
                return 'normal';
            } else if (deviationPercent <= 10) { // > 5% and <= 10%
                return 'slight';
            } else if (deviationPercent <= 20) { // > 10% and <= 20%
                return 'low';
            } else if (deviationPercent <= 30) { // > 20% and <= 30%
                return 'high';
            } else { // > 30%
                return 'critical';
            }
        }
        
        // Helper to get color based on alert level
        function getAlertColor(alertLevel) {
            switch(alertLevel) {
                case 'critical': return '#e74c3c';
                case 'high': return '#f39c12';
                case 'low': return '#f1c40f';
                case 'normal': return '#27ae60';
                default: return '#95a5a6'; // Default grey
            }
        }
        
        // --- Validation Message Handling ---
        function addValidationMessage(type, message) {
            validationMessages.push({ type, message });
            console.log(`Validation (${type}): ${message}`);
        }

        function displayValidationMessages() {
            const section = document.getElementById('validationSection');
            const list = document.getElementById('validationMessages');
            if (!section || !list) return;

            list.innerHTML = ''; // Clear previous messages
            if (validationMessages.length === 0) {
                list.innerHTML = '<li class="success">Data and benchmarks loaded successfully with no issues detected.</li>';
            } else {
                validationMessages.forEach(msg => {
                    const item = document.createElement('li');
                    item.classList.add(msg.type); // Add class 'error', 'warning', or 'success'
                    item.textContent = msg.message;
                    list.appendChild(item);
                });
            }
            section.style.display = 'block'; // Show the section
        }

        // --- UI Initialization & Update Functions ---
        
        function initializeDatePickers() {
             $(function() {
                $('#dateRangePicker').daterangepicker({
                    startDate: dateRange.start,
                    endDate: dateRange.end,
                    opens: 'left',
                    ranges: {
                       'Last 4 Weeks': [moment().subtract(4, 'weeks'), moment()],
                       'Last 8 Weeks': [moment().subtract(8, 'weeks'), moment()],
                       'Last 3 Months': [moment().subtract(3, 'months'), moment()],
                       'Last 6 Months': [moment().subtract(6, 'months'), moment()],
                       'Year to Date': [moment().startOf('year'), moment()],
                       'Last Year': [moment().subtract(1, 'year').startOf('year'), moment().subtract(1, 'year').endOf('year')]
                    }
                }, function(start, end, label) {
                    dateRange.start = start;
                    dateRange.end = end;
                    updateHistoricalCharts();
                });

                $('#compareRangePicker1, #compareRangePicker2').daterangepicker({
                    singleDatePicker: false,
                    opens: 'left',
                     ranges: {
                       'Last Week': [moment().subtract(1, 'week').startOf('week'), moment().subtract(1, 'week').endOf('week')],
                       'Last Month': [moment().subtract(1, 'month').startOf('month'), moment().subtract(1, 'month').endOf('month')],
                       'Last Quarter': [moment().subtract(1, 'quarter').startOf('quarter'), moment().subtract(1, 'quarter').endOf('quarter')]
                    }
                });
            });
        }
        
        // Populate metric selector buttons in historical tab
        function populateMetricSelector() {
            const selectorDiv = document.getElementById('metricSelector');
            selectorDiv.innerHTML = ''; // Clear existing
            metricsDefinition.forEach((metric, index) => {
                // if (metric.type === 'text') return; // Already filtered in definition
                const button = document.createElement('button');
                button.dataset.metric = metric.id;
                button.textContent = metric.name;
                if (metric.id === selectedMetric) {
                    button.classList.add('active');
                }
                button.addEventListener('click', function() {
                    selectMetric(this.dataset.metric);
                });
                selectorDiv.appendChild(button);
            });
        }
        
// This will create the time period filter dropdown using the actual 'Date of week' values from Data and Benchmark
function populateTimePeriodFilter() {
    const selector = document.getElementById('timePeriodFilter');
    selector.innerHTML = ''; // Clear existing

    // Collect all unique dates from Data and Benchmark
    const allDataDates = Object.values(allClinicsData)
        .flat()
        .map(entry => entry["Date of week"])
        .filter(Boolean);

    const allBenchmarkDates = Object.values(benchmarkData)
        .map(entry => entry["Date of week"])
        .filter(Boolean);

    const allDates = Array.from(new Set([...allDataDates, ...allBenchmarkDates]))
        .sort((a, b) => new Date(b) - new Date(a)); // newest first

    allDates.forEach(dateStr => {
        const option = document.createElement('option');
        option.value = dateStr;
        option.textContent = moment(dateStr).format('MMM D, YYYY');
        selector.appendChild(option);
    });

    // Default to latest date
    if (allDates.length > 0) {
        selector.value = allDates[0];
    }
}
        // Populate clinic filter options in all relevant dropdowns
        function populateClinicOptions() {
            const clinicNames = Object.keys(allClinicsData).sort();
            const selectors = [
                document.getElementById('clinicFilter'),
                document.getElementById('clinicSelector'),
                document.getElementById('compareClinicSelectorW2W'),
                document.getElementById('compareClinicSelector4W'),
                document.getElementById('compareClinicSelectorCR')
            ];
            
            selectors.forEach(selector => {
                if (!selector) return;
                const currentValue = selector.value;
                // Clear existing options except the first one ('All Clinics')
                while (selector.options.length > 1) {
                    selector.remove(1);
                }
                // Add clinic options
                clinicNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    selector.appendChild(option);
                });
                // Restore previous selection if possible
                if (clinicNames.includes(currentValue)) {
                    selector.value = currentValue;
                } else {
                    selector.value = 'all'; // Default to 'all'
                }
            });
        }

        // Populate week selector options for comparison tab
        function populateWeekSelectors() {
            const selectors = [
                document.getElementById('compareWeek1'),
                document.getElementById('compareWeek2'),
                document.getElementById('compareWeek3'),
                document.getElementById('compareWeek4')
            ];
            
            selectors.forEach((selector, index) => {
                if (!selector) return;
                selector.innerHTML = ''; // Clear existing options
                availableWeeks.forEach(week => {
                    const option = document.createElement('option');
                    option.value = `${week.year}-W${week.week}`;
                    option.textContent = `${moment(week.date).format('MMM D, YYYY')}`;
                    selector.appendChild(option);
                });
                // Set default selected week (e.g., last 4 weeks)
                const defaultIndex = Math.max(0, availableWeeks.length - 1 - index);
                 if (availableWeeks.length > defaultIndex) {
                    selector.selectedIndex = defaultIndex;
                }
            });
        }

        // Update summary cards based on the provided data array
        function updateSummaryCards(data) {
            const summaryCardsContainer = document.getElementById('summaryCards');
            if (!data || data.length === 0) {
                 summaryCardsContainer.innerHTML = '<div class="summary-card"><p>No data available for the selected period/filters.</p></div>';
                 return;
            }
            
            const alertCounts = { critical: 0, high: 0, low: 0, normal: 0 };
            data.forEach(clinic => {
                 alertCounts[clinic.overallAlert]++;
            });
            
            const summaryCardsHTML = `
                <div class="summary-card">
                    <h3>Critical Alerts</h3>
                    <div class="number critical">${alertCounts.critical}</div>
                    <div>Require Immediate Action</div>
                </div>
                <div class="summary-card">
                    <h3>High Alerts</h3>
                    <div class="number high">${alertCounts.high}</div>
                    <div>Need Attention</div>
                </div>
                <div class="summary-card">
                    <h3>Low Alerts</h3>
                    <div class="number low">${alertCounts.low}</div>
                    <div>Monitor Closely</div>
                </div>
                <div class="summary-card">
                    <h3>Normal Performance</h3>
                    <div class="number normal">${alertCounts.normal}</div>
                    <div>Meeting Targets</div>
                </div>
            `;
            summaryCardsContainer.innerHTML = summaryCardsHTML;
        }
        
        // Update the 'Last Updated' timestamp
        function updateLastUpdated() {
            const lastUpdatedDiv = document.getElementById('lastUpdated');
            if (latestWeek.year > 0) {
                 const currentMoment = moment();
                 lastUpdatedDiv.textContent = `Data Loaded: ${currentMoment.format('MMM D, YYYY HH:mm')} | Latest Data: ${moment(latestWeek.date).format('MMM D, YYYY')}`;
            } else {
                 lastUpdatedDiv.textContent = 'No data loaded.';
            }
        }

        // Populate table with data
        function populateTable(data) {
            const tbody = document.getElementById('tableBody');
            const title = document.getElementById('tableTitle');
            if (!tbody) { console.error("Table body not found!"); return; }
            tbody.innerHTML = ''; // Clear previous rows
            
            const timePeriod = document.getElementById('timePeriodFilter').value;
            const weekInfo = (timePeriod === 'current' && latestWeek.year > 0) ? latestWeek : previousWeek;
            title.textContent = `Clinic Performance Overview - ${moment(weekInfo.date).format('MMM D, YYYY') || 'N/A'}`;
            
            if (!data || data.length === 0) {
                tbody.innerHTML = '<tr><td colspan="23" style="text-align: center;">No data available for the selected filters.</td></tr>'; // Updated colspan
                return;
            }

            data.forEach(clinic => {
                const row = document.createElement('tr');
                const notesAlert = clinic['areaManagerNotesAlertLevel'] || 'normal'; // Use processed level
                
                row.innerHTML = `
                    <td class="clinic-name">${clinic.Clinic}</td>
                    <!-- AreaManagerNotes removed -->
                    <td><span class="alert-badge alert-${notesAlert}">${notesAlert.toUpperCase()}</span></td> <!-- Manual Alert Cell -->
                    ${generateMetricCell(clinic, 'newPatients')}
                    ${generateMetricCell(clinic, 'visitsTarget')}
                    ${generateMetricCell(clinic, 'dailyDistribution')}
                    ${generateMetricCell(clinic, 'utilization')}
                    ${generateMetricCell(clinic, 'retention2nd')}
                    ${generateMetricCell(clinic, 'retention5th')}
                    ${generateMetricCell(clinic, 'retention10th')}
                    ${generateMetricCell(clinic, 'retention15th')}
                    ${generateMetricCell(clinic, 'cancel')}
                    ${generateMetricCell(clinic, 'noShow')}
                    ${generateMetricCell(clinic, 'noUpcoming')}
                    ${generateMetricCell(clinic, 'units')}
                    ${generateMetricCell(clinic, 'insuranceCoding')}
                    ${generateMetricCell(clinic, 'supportiveCoding')}
                    ${generateMetricCell(clinic, 'confirmation')}
                    ${generateMetricCell(clinic, 'directAccess')}
                    ${generateMetricCell(clinic, 'surveyCollection')}
                    ${generateMetricCell(clinic, 'satisfaction')}
                    <td class="metric-value">
                        <span class="alert-badge alert-${clinic.overallAlert}">${clinic.overallAlert.toUpperCase()}</span>
                    </td>
                    <td class="metric-value">
                        ${clinic.weeklyTrend || 'N/A'}
                    </td>
                    <td>
                        <button class="action-button" onclick="showDetails('${clinic.Clinic}')">Details</button>
                    </td>
                `;
                tbody.appendChild(row);
            });
        }
        
        // Helper to generate HTML for a metric table cell (Handles CSV header case)
        function generateMetricCell(clinicData, metricId) {
            const metricDef = metricsDefinition.find(m => m.id === metricId);
            if (!metricDef) return '<td>Error</td>';

            // Use correct CSV header case (e.g., NewPatients)
            const csvHeader = metricId.charAt(0).toUpperCase() + metricId.slice(1);
            const value = clinicData[csvHeader];
            const alert = clinicData[metricId + 'Alert'] || 'normal';
            const trend = clinicData[metricId + 'Trend'] || 'same';
            
            // Get dynamic benchmark for display
            const weekKey = `${clinicData.Year}-W${clinicData.Week}`;
            const weeklyBenchmarks = benchmarkData[weekKey];
            const target = weeklyBenchmarks ? weeklyBenchmarks[csvHeader] : null;
            
            let displayValue = 'N/A';
            let targetText = '';

            if (value !== null && value !== undefined) {
                displayValue = metricDef.type === 'percentage' ? `${value}%` : value;
            }
            
            if (target !== null && target !== undefined) {
                 targetText = metricDef.type === 'percentage' ? `Target: ${target}%` : `Target: ${target}`;
            } else {
                 targetText = 'Target: N/A'; // Indicate if benchmark is missing
            }

            return `
                <td class="metric-value">
                    ${displayValue}
                    <span class="alert-badge alert-${alert}">${alert.toUpperCase()}</span>
                    <span class="trend-arrow trend-${trend}">${getTrendArrow(trend)}</span>
                    <div class="deviation">${targetText}</div>
                </td>
            `;
        }

        // Populate card view
        function populateCardView(data) {
            const cardContainer = document.getElementById('cardView');
            if (!cardContainer) return;
            cardContainer.innerHTML = '';

             if (!data || data.length === 0) {
                cardContainer.innerHTML = '<p style="text-align: center; grid-column: 1 / -1;">No data available for the selected filters.</p>';
                return;
            }

            data.forEach(clinic => {
                const notesAlert = clinic['areaManagerNotesAlertLevel'] || 'normal';
                card = document.createElement('div');
                card.className = 'summary-card'; // Reuse summary card style
                card.innerHTML = `
                    <h3 class="clinic-name">${clinic.Clinic}</h3>
                    <div class="number ${clinic.overallAlert}">${clinic.overallAlert.toUpperCase()}</div>
                    <div>Overall Status</div>
                    <p style="font-size: 0.8em; margin-top: 10px;">Trend: ${clinic.weeklyTrend || 'N/A'}</p>
                    <p style="font-size: 0.8em; margin-top: 5px;">Notes Alert: <span class="alert-badge alert-${notesAlert}">${notesAlert.toUpperCase()}</span></p>
                     <button class="action-button" style="margin-top: 15px;" onclick="showDetails('${clinic.Clinic}')">Details</button>
                `;
                cardContainer.appendChild(card);
            });
        }
        
        // Enable controls after data load
        function enableControls() {
            document.querySelectorAll('.controls select, .controls input, .controls button, .view-toggle button, .tab-buttons
